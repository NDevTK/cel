// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package common

import (
	"fmt"
	"reflect"

	"chromium.googlesource.com/enterprise/cel/go/schema"
	commonpb "chromium.googlesource.com/enterprise/cel/go/schema/common"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"google.golang.org/protobuf/runtime/protoimpl"
)

const kNoMethodFoundError = `No "Validate" method found for type %s.

See documentation at //go/schema/validator_registry.go for more information
about adding a validation method for this type.
`

const kInvalidSignatureError = `The "Validate" method for type %s has an incorrect type.

Expected:
    func Validate(%s) error

Actual:
    %s
`

// ValidateProto analyzes the data structure at |a| and invokes the validate
// method (see //go/schema/validator_registry.go) on objects that implement
// proto.Message and have a validation method.
//
// In other words, it recursively invokes Validate() on proto objects rooted at
// |a|.
//
// If |a| is a pointer to a structure, (say, *Foo), and |a| implements
// message.Proto, then Foo is assumed to be a protobuf generated message. By
// convention there should be a Validate() method for *Foo (i.e. a function
// matching the signature 'func (*Foo) Validate() error'). This function is
// expected to do basic validation on the data as a means of providing an early
// warning if something is out of line.
//
// *Foo -- or Foo -- might contain fields that are themselves protobuf
// messages, in which case ValidateProto() recurses into each field to
// validate the entire data structure.
//
// See //docs/schema-guidelines.md for more details on why we are doing things
// this way.
func ValidateProto(a interface{}, r RefPath) error {
	return WalkProtoValue(reflect.ValueOf(a), r, invokeValidateOnValue)
}

// invokeValidateOnValue is a WalkProtoFunc that invokes the Validate() method
// if one is found for a proto.Message object. It returns an error if the class
// is missing a Validate() method.
func invokeValidateOnValue(av reflect.Value, p RefPath, d *descriptor.FieldDescriptorProto) (bool, error) {
	// A field
	if d != nil {
		return validateAnnotatedField(av, d)
	}

	// The only field type we are interested in is of the form:
	//     FooField *FooType
	// ... where *FooType implements proto.Message.
	if av.Kind() != reflect.Ptr || !av.Type().Implements(reflect.TypeOf((*proto.Message)(nil)).Elem()) {
		return true, nil
	}

	// Skip nil fields. If the field was required, then the prior validation
	// step would've caught it.
	if av.IsNil() {
		return true, nil
	}

	// Search for the Validate method.
	mv, err := schema.GetValidateFunction(av.Type())
	if err != nil {
		return true, fmt.Errorf(kNoMethodFoundError, av.Type().String())
	}

	if mv.Type().NumIn() != 1 || mv.Type().NumOut() != 1 || mv.Type().Out(0).Kind() != reflect.Interface {
		return true, fmt.Errorf(kInvalidSignatureError, av.Type().String(), av.Type().String(), mv.Type().String())
	}

	result := mv.Call([]reflect.Value{av})
	if len(result) != 1 {
		return true, fmt.Errorf(kInvalidSignatureError, av.Type().String(), av.Type().String(), mv.Type().String())
	}

	if result[0].IsNil() {
		return true, nil
	}

	err, ok := result[0].Interface().(error)
	if !ok {
		return true, fmt.Errorf(kInvalidSignatureError, av.Type().String(), av.Type().String(), mv.Type().String())
	}
	return true, err
}

// GetValidationForField queries the field extensions for |fd| and returns a
// Validation object if one is found. If there is no Validation extension for
// this field, returns an object representing the default set of validation
// rules that should be applied to |fd|.
func GetValidationForField(fd *descriptor.FieldDescriptorProto) *commonpb.Validation {
	var v *commonpb.Validation

	if fd.Options != nil {
		ex, err := proto.GetExtension(fd.Options, commonpb.E_V)
		if err == nil {
			v = ex.(*commonpb.Validation)
		}
	}

	if v == nil {
		v = &commonpb.Validation{}
	}

	if v.Type == commonpb.Validation_UNKNOWN {
		if fd.GetName() == "name" {
			v.Type = commonpb.Validation_LABEL
		}

		if v.GetRef() != "" {
			v.Type = commonpb.Validation_REQUIRED
		}
	}

	return v
}

// validateAnnotatedField performs validation for a field which has one or more
// of the annotations in //schema/common/validation.proto.
func validateAnnotatedField(af reflect.Value, fd *descriptor.FieldDescriptorProto) (bool, error) {
	v := GetValidationForField(fd)

	if IsOutput(v) {
		// Output values  are special. They are generated by the toolchain
		// itself, and hence are excluded from validation. As a side-effect,
		// output values that are external protobufs (i.e. protobufs that are
		// defined by external sources and hence don't have validators) are
		// excluded from validation.
		return false, nil
	}

	// Skip over optional fields if empty.
	if v.GetOptional() {
		switch {
		case af.Kind() == reflect.String && af.Len() == 0:
			fallthrough
		case af.Kind() == reflect.Slice && af.Len() == 0:
			fallthrough
		case af.Kind() == reflect.Ptr && af.IsNil():
			fallthrough
		case af.Kind() == reflect.Interface && af.IsNil():
			return true, nil
		}
	}

	switch v.Type {
	case commonpb.Validation_REQUIRED:
		switch {
		case af.Kind() == reflect.String && af.Len() == 0:
			return true, fmt.Errorf("required field '%s' was not specified", fd.GetName())
		case (af.Kind() == reflect.Interface || af.Kind() == reflect.Ptr) && af.IsNil():
			return true, fmt.Errorf("'%s' is required", fd.GetName())
		case (af.Kind() == reflect.Map || af.Kind() == reflect.Slice) && af.Len() == 0:
			return true, fmt.Errorf("at least one of '%s' should be specified", fd.GetName())
		}

	case commonpb.Validation_LABEL:
		if af.Kind() != reflect.String {
			return true, fmt.Errorf("unexpected type for label field: %#v", af)
		}

		if ContainsInlineReferences(af.String()) {
			return true, nil
		}

		return true, IsRFC1035Label(af.String())

	case commonpb.Validation_FQDN:
		if af.Kind() != reflect.String {
			return true, fmt.Errorf("unexpected kind for validatable field: %#v", af)
		}

		if ContainsInlineReferences(af.String()) {
			return true, nil
		}

		return true, IsRFC1035Domain(af.String())

	case commonpb.Validation_ORGLABEL:
		if af.Kind() != reflect.String {
			return true, fmt.Errorf("unexpected kind for validatable field: %#v", af)
		}

		if ContainsInlineReferences(af.String()) {
			return true, nil
		}

		return true, IsRFC1035DomainLabel(af.String())

	case commonpb.Validation_TOPLEVEL:
		if af.Kind() != reflect.Slice {
			return true, fmt.Errorf("TOPLEVEL attribute should only be applied to a collection")
		}

	}
	return true, nil
}

// VerifyValidatableType checks whether all types that implement proto.Message
// rooted at a given type and have a registered Validate method.
func VerifyValidatableType(at reflect.Type) error {
	err_list := []error{}

	switch at.Kind() {
	case reflect.Slice:
		return VerifyValidatableType(at.Elem())

	case reflect.Ptr:
		// |at| is a Type for *Foo. First dive down and examine Foo.
		err_list = AppendErrorList(err_list, VerifyValidatableType(at.Elem()))

		// In case there were 'oneof' fields...
		err_list = AppendErrorList(err_list, verifyOneOfTypes(at))

		// If *Foo doesn't implement proto.Message, assume this is something
		// else and don't look any further.
		if !at.Implements(ProtoMessageType) {
			break
		}

		// *Foo *should* have a Validate method since it implements proto.Message.
		mt, err := schema.GetValidateFunction(at)
		if err != nil {
			err_list = AppendErrorList(err_list, fmt.Errorf(kNoMethodFoundError, at.String()))
			break
		}

		// We can only check the method signature since we don't have a value.
		if mt.Type().NumIn() != 1 || mt.Type().NumOut() != 1 || mt.Type().Out(0) != reflect.TypeOf((*error)(nil)).Elem() {
			err_list = AppendErrorList(err_list,
				fmt.Errorf(kInvalidSignatureError, at.Elem().String(), at.Elem().String(), mt.Type().String()))
			break
		}

	case reflect.Struct:
		fpm := constructFieldToDescriptorMap(reflect.New(at).Elem())
		for i := 0; i < at.NumField(); i++ {
			// avoid stack overflow exception. "messageinfo" circularly  declared, MessageInfo->coderMessageInfo->coderFieldInfo->MessageInfo.
			if at.Field(i).Type == reflect.TypeOf(protoimpl.MessageState{}) {
				continue
			}
			if fd, ok := fpm[at.Field(i).Name]; ok {
				v := GetValidationForField(fd)
				if IsOutput(v) {
					continue
				}
			}
			sf := at.Field(i)
			err_list = AppendErrorList(err_list, VerifyValidatableType(sf.Type))
		}
	}

	return WrapErrorList(err_list)
}

// verifyOneOfTypes attempts to verify related subtypes that are used for
// implementing 'oneof' support in ProtoBufs.
//
// |pt| is a reflect.Type for a proto.Message implementation. For protoc
// generated code, it is always type representing a pointer to a struct. E.g.
// type of *Foo if *Foo implements proto.Message.
//
// Here's where things get tricky. The only connection we have from |pt| to the
// candidates oneof field subtypes is via the XXX_OneofFuncs() internal proto
// method. It is likely that this will break in the future. There are panics
// scattered around to catch minor deviations, but won't catch major
// deviations.
//
// |pt| is a |Ptr| type which we suspect may contain 'oneof' fields.
func verifyOneOfTypes(pt reflect.Type) error {
	mt, ok := pt.MethodByName("XXX_OneofFuncs")
	if !ok {
		// I guess it wasn't a oneof. Or, y'know, proto decided to change
		// this implementation detail.
		return nil
	}

	// mt is a method matching the signature:
	//
	//     func (*Foo) XXX_OneofFuncs() (
	//       func(msg proto.Message, b *proto.Buffer) error,
	//       func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error),
	//       func(msg proto.Message) (n int),
	//       []interface{})
	//
	// The receiver is unused. So we can pass in a reflect.Zero(pt). Of the
	// results, we are only interested in the last one.
	results := mt.Func.Call([]reflect.Value{reflect.Zero(pt)})
	if len(results) != 4 {
		panic("XXX_OneofFuncs behaved in an unexpected way")
	}

	// clist is a reflect.Value representing a []interface{} where each element
	// is nil cast to *Type, where Type is a oneof substrate for |pt|'s
	// underlying type. |pt| may have more than one one-of field. Either way
	// this list should have all of them. We don't care about which type
	// matches with which field since we have to validate all of them.
	clist := results[3]
	if clist.Kind() != reflect.Slice {
		panic("Unexpected return type for interface list")
	}

	err_list := []error{}
	for i := 0; i < clist.Len(); i++ {
		ci := clist.Index(i)
		if ci.Kind() != reflect.Interface {
			panic("Unexpected return type for interface list")
		}
		// conveniently, ci is now a reflect.Value whose Type is the type
		// implementing the one-of substrate we want to examine.
		ct := reflect.TypeOf(ci.Interface())
		err_list = AppendErrorList(err_list, VerifyValidatableType(ct))
	}
	return WrapErrorList(err_list)
}
