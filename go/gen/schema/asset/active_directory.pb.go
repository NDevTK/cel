// Code generated by protoc-gen-go.
// source: schema/asset/active_directory.proto
// DO NOT EDIT!

/*
Package asset is a generated protocol buffer package.

It is generated from these files:
	schema/asset/active_directory.proto

It has these top-level messages:
	ActiveDirectoryDomain
	ActiveDirectoryDomainController
	WindowsContainer
	WindowsGroup
	WindowsUser
	NetworkInterface
	WindowsMachine
*/
package asset

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import net "schema/asset"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ActiveDirectoryDomain struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *ActiveDirectoryDomain) Reset()                    { *m = ActiveDirectoryDomain{} }
func (m *ActiveDirectoryDomain) String() string            { return proto.CompactTextString(m) }
func (*ActiveDirectoryDomain) ProtoMessage()               {}
func (*ActiveDirectoryDomain) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ActiveDirectoryDomain) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ActiveDirectoryDomainController struct {
	Domain  string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	Machine string `protobuf:"bytes,2,opt,name=machine" json:"machine,omitempty"`
}

func (m *ActiveDirectoryDomainController) Reset()                    { *m = ActiveDirectoryDomainController{} }
func (m *ActiveDirectoryDomainController) String() string            { return proto.CompactTextString(m) }
func (*ActiveDirectoryDomainController) ProtoMessage()               {}
func (*ActiveDirectoryDomainController) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ActiveDirectoryDomainController) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *ActiveDirectoryDomainController) GetMachine() string {
	if m != nil {
		return m.Machine
	}
	return ""
}

// Describes a container that a Windows asset can reside in.
//
// Resources like machines, users, and groups can be specified per domain, per
// machine, or per organizational unit. When specifying one of these asset
// types, use the WindowsContainer member to specify where to create the asset.
type WindowsContainer struct {
	// Types that are valid to be assigned to Container:
	//	*WindowsContainer_Domain
	//	*WindowsContainer_Machine
	//	*WindowsContainer_Ou
	Container isWindowsContainer_Container `protobuf_oneof:"container"`
}

func (m *WindowsContainer) Reset()                    { *m = WindowsContainer{} }
func (m *WindowsContainer) String() string            { return proto.CompactTextString(m) }
func (*WindowsContainer) ProtoMessage()               {}
func (*WindowsContainer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isWindowsContainer_Container interface {
	isWindowsContainer_Container()
}

type WindowsContainer_Domain struct {
	Domain string `protobuf:"bytes,1,opt,name=domain,oneof"`
}
type WindowsContainer_Machine struct {
	Machine string `protobuf:"bytes,2,opt,name=machine,oneof"`
}
type WindowsContainer_Ou struct {
	Ou string `protobuf:"bytes,3,opt,name=ou,oneof"`
}

func (*WindowsContainer_Domain) isWindowsContainer_Container()  {}
func (*WindowsContainer_Machine) isWindowsContainer_Container() {}
func (*WindowsContainer_Ou) isWindowsContainer_Container()      {}

func (m *WindowsContainer) GetContainer() isWindowsContainer_Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *WindowsContainer) GetDomain() string {
	if x, ok := m.GetContainer().(*WindowsContainer_Domain); ok {
		return x.Domain
	}
	return ""
}

func (m *WindowsContainer) GetMachine() string {
	if x, ok := m.GetContainer().(*WindowsContainer_Machine); ok {
		return x.Machine
	}
	return ""
}

func (m *WindowsContainer) GetOu() string {
	if x, ok := m.GetContainer().(*WindowsContainer_Ou); ok {
		return x.Ou
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WindowsContainer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WindowsContainer_OneofMarshaler, _WindowsContainer_OneofUnmarshaler, _WindowsContainer_OneofSizer, []interface{}{
		(*WindowsContainer_Domain)(nil),
		(*WindowsContainer_Machine)(nil),
		(*WindowsContainer_Ou)(nil),
	}
}

func _WindowsContainer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WindowsContainer)
	// container
	switch x := m.Container.(type) {
	case *WindowsContainer_Domain:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Domain)
	case *WindowsContainer_Machine:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Machine)
	case *WindowsContainer_Ou:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Ou)
	case nil:
	default:
		return fmt.Errorf("WindowsContainer.Container has unexpected type %T", x)
	}
	return nil
}

func _WindowsContainer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WindowsContainer)
	switch tag {
	case 1: // container.domain
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Container = &WindowsContainer_Domain{x}
		return true, err
	case 2: // container.machine
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Container = &WindowsContainer_Machine{x}
		return true, err
	case 3: // container.ou
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Container = &WindowsContainer_Ou{x}
		return true, err
	default:
		return false, nil
	}
}

func _WindowsContainer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WindowsContainer)
	// container
	switch x := m.Container.(type) {
	case *WindowsContainer_Domain:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Domain)))
		n += len(x.Domain)
	case *WindowsContainer_Machine:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Machine)))
		n += len(x.Machine)
	case *WindowsContainer_Ou:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Ou)))
		n += len(x.Ou)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type WindowsGroup struct {
	// Name of the group. Exclude the domain name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Human readable description of the group.
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// Container for the group. A container must be specified for a WindowsGroup.
	Container *WindowsContainer `protobuf:"bytes,3,opt,name=container" json:"container,omitempty"`
	// Well-known security identifier. The string should be of the form S-* and
	// should correspond to a known SID as described in
	// https://support.microsoft.com/en-us/help/243330/well-known-security-identifiers-in-windows-operating-systems.
	//
	// Only specify this field if this group corresponds to a well known group.
	WellKnownSid string `protobuf:"bytes,4,opt,name=well_known_sid,json=wellKnownSid" json:"well_known_sid,omitempty"`
}

func (m *WindowsGroup) Reset()                    { *m = WindowsGroup{} }
func (m *WindowsGroup) String() string            { return proto.CompactTextString(m) }
func (*WindowsGroup) ProtoMessage()               {}
func (*WindowsGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *WindowsGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WindowsGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *WindowsGroup) GetContainer() *WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *WindowsGroup) GetWellKnownSid() string {
	if m != nil {
		return m.WellKnownSid
	}
	return ""
}

type WindowsUser struct {
	// Name of the user. Exclude the domain name.
	//
	// E.g.: joe
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Description. A.k.a. Full name.
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// Container for the user. A container must be specified for a WindowsUser.
	Container *WindowsContainer `protobuf:"bytes,3,opt,name=container" json:"container,omitempty"`
	// Password. Can be left blank in which case each instantiation of the lab
	// will cause a new password to be generated.
	Password string `protobuf:"bytes,5,opt,name=password" json:"password,omitempty"`
}

func (m *WindowsUser) Reset()                    { *m = WindowsUser{} }
func (m *WindowsUser) String() string            { return proto.CompactTextString(m) }
func (*WindowsUser) ProtoMessage()               {}
func (*WindowsUser) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *WindowsUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WindowsUser) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *WindowsUser) GetContainer() *WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *WindowsUser) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// NetworkInterface describes a single network interface on a machine.
type NetworkInterface struct {
	// Name of |schema.Network| entry describing the network that this interface
	// is attached to.
	Network string `protobuf:"bytes,1,opt,name=network" json:"network,omitempty"`
	// Fixed address, if this interface is to have one. Leave undefined if the
	// interface should obatain an address automatically.
	FixedAddress *net.FixedAddress `protobuf:"bytes,2,opt,name=fixed_address,json=fixedAddress" json:"fixed_address,omitempty"`
}

func (m *NetworkInterface) Reset()                    { *m = NetworkInterface{} }
func (m *NetworkInterface) String() string            { return proto.CompactTextString(m) }
func (*NetworkInterface) ProtoMessage()               {}
func (*NetworkInterface) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NetworkInterface) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *NetworkInterface) GetFixedAddress() *net.FixedAddress {
	if m != nil {
		return m.FixedAddress
	}
	return nil
}

// A Windows machine.
//
type WindowsMachine struct {
	// Name of the machine. This name will become the hostname for the machine,
	// both absolute and domain relative (if applicable). Hence must be globally
	// unique.
	//
	// For Windows machines, it's advisable to have *short* hostnames, ideally
	// shorter than 11 characters. This allows the name to do double duty as a
	// NetBios name as well as a DNS hostname.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Container. Only |domain| and |ou| values are acceptable. Currently
	// |machine| is not a valid option. If no container is specified, the machine
	// will be brought up as a standalone workstation or server depending on the
	// installed operating system.
	//
	// This field should be empty for a machine that's referenced in a
	// ActiveDirectoryDomainController entry.
	//
	// Specifying this field results in the machine being joined to the specified
	// domain and, if necessary, placed in the specified container.
	Container *WindowsContainer `protobuf:"bytes,3,opt,name=container" json:"container,omitempty"`
	// The name of a host.MachineType entry that describes the host machine.
	HostMachineType string `protobuf:"bytes,4,opt,name=host_machine_type,json=hostMachineType" json:"host_machine_type,omitempty"`
	// System locale. If left unspecified, the default is left unchanged. Use the
	// following PowerShell command to determine the list of available locales on
	// a Windows machine:
	//
	// ``` ps1
	// [System.Globalization.CultureInfo]::GetCultures([System.Globalization.CultureTypes]::AllCultures).name
	// ```
	//
	// PS DSC Reference:
	// * https://github.com/PowerShell/SystemLocaleDsc
	Locale string `protobuf:"bytes,5,opt,name=locale" json:"locale,omitempty"`
	// Set the system timezone. If left unspecified, the default is left
	// unchanged. Use the following PowerShell command to determine the lsit of
	// available timezone identifiers on a Windows machine:
	//
	// ``` ps1
	// [System.TimeZoneInfo]::GetSystemTimeZones().Id
	// ```
	//
	// PS DSC Reference:
	// * https://github.com/PowerShell/xTimeZone
	Timezone string `protobuf:"bytes,6,opt,name=timezone" json:"timezone,omitempty"`
	// Network interfaces. There can be more than one for multihomed machines.
	// There MUST be at least one of these.
	NetworkInterface []*NetworkInterface `protobuf:"bytes,7,rep,name=network_interface,json=networkInterface" json:"network_interface,omitempty"`
}

func (m *WindowsMachine) Reset()                    { *m = WindowsMachine{} }
func (m *WindowsMachine) String() string            { return proto.CompactTextString(m) }
func (*WindowsMachine) ProtoMessage()               {}
func (*WindowsMachine) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *WindowsMachine) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WindowsMachine) GetContainer() *WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *WindowsMachine) GetHostMachineType() string {
	if m != nil {
		return m.HostMachineType
	}
	return ""
}

func (m *WindowsMachine) GetLocale() string {
	if m != nil {
		return m.Locale
	}
	return ""
}

func (m *WindowsMachine) GetTimezone() string {
	if m != nil {
		return m.Timezone
	}
	return ""
}

func (m *WindowsMachine) GetNetworkInterface() []*NetworkInterface {
	if m != nil {
		return m.NetworkInterface
	}
	return nil
}

func init() {
	proto.RegisterType((*ActiveDirectoryDomain)(nil), "winad.ActiveDirectoryDomain")
	proto.RegisterType((*ActiveDirectoryDomainController)(nil), "winad.ActiveDirectoryDomainController")
	proto.RegisterType((*WindowsContainer)(nil), "winad.WindowsContainer")
	proto.RegisterType((*WindowsGroup)(nil), "winad.WindowsGroup")
	proto.RegisterType((*WindowsUser)(nil), "winad.WindowsUser")
	proto.RegisterType((*NetworkInterface)(nil), "winad.NetworkInterface")
	proto.RegisterType((*WindowsMachine)(nil), "winad.WindowsMachine")
}

func init() { proto.RegisterFile("schema/asset/active_directory.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 460 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x53, 0xc1, 0x8e, 0xd3, 0x30,
	0x10, 0xdd, 0x76, 0xb7, 0x2d, 0x3b, 0x29, 0x4b, 0x6b, 0x09, 0xb0, 0x7a, 0xa1, 0x0a, 0x1c, 0x10,
	0x48, 0x59, 0x69, 0x11, 0xdc, 0x77, 0xa9, 0x60, 0x11, 0x82, 0x43, 0x17, 0x84, 0xc4, 0x25, 0x32,
	0xf1, 0x94, 0x5a, 0x9b, 0x78, 0x22, 0xdb, 0x25, 0x94, 0x1b, 0x3f, 0xc1, 0x9d, 0x3f, 0x45, 0x71,
	0x9d, 0xd2, 0x8d, 0x7a, 0xe2, 0xc0, 0x2d, 0xef, 0xcd, 0xf8, 0xf9, 0xf9, 0xcd, 0x04, 0x1e, 0xda,
	0x6c, 0x89, 0x85, 0x38, 0x15, 0xd6, 0xa2, 0x3b, 0x15, 0x99, 0x53, 0xdf, 0x30, 0x95, 0xca, 0x60,
	0xe6, 0xc8, 0xac, 0x93, 0xd2, 0x90, 0x23, 0xd6, 0xab, 0x94, 0x16, 0x72, 0x32, 0xb9, 0xd1, 0xab,
	0xd1, 0x55, 0x64, 0xae, 0x37, 0x2d, 0xf1, 0x53, 0xb8, 0x7b, 0xee, 0x0f, 0xcf, 0x9a, 0xb3, 0x33,
	0x2a, 0x84, 0xd2, 0x8c, 0xc1, 0x91, 0x16, 0x05, 0xf2, 0xce, 0xb4, 0xf3, 0xf8, 0x78, 0xee, 0xbf,
	0xe3, 0x2b, 0x78, 0xb0, 0xb7, 0xf9, 0x25, 0x69, 0x67, 0x28, 0xcf, 0xd1, 0xb0, 0x7b, 0xd0, 0x97,
	0x9e, 0x0b, 0x07, 0x03, 0x62, 0x1c, 0x06, 0x85, 0xc8, 0x96, 0x4a, 0x23, 0xef, 0xfa, 0x42, 0x03,
	0xe3, 0xaf, 0x30, 0xfa, 0xa4, 0xb4, 0xa4, 0xca, 0xd6, 0x32, 0x42, 0x69, 0x34, 0x8c, 0xdf, 0x54,
	0xb9, 0x3c, 0xd8, 0xea, 0x4c, 0x5a, 0x3a, 0x97, 0x07, 0x5b, 0x25, 0x36, 0x82, 0x2e, 0xad, 0xf8,
	0x61, 0xa0, 0xbb, 0xb4, 0xba, 0x88, 0xe0, 0x38, 0x6b, 0x44, 0xe3, 0xdf, 0x1d, 0x18, 0x86, 0x9b,
	0x5e, 0x1b, 0x5a, 0x95, 0xfb, 0x9e, 0xc8, 0xa6, 0x10, 0x49, 0xb4, 0x99, 0x51, 0xa5, 0x53, 0xa4,
	0x83, 0xd7, 0x5d, 0x8a, 0x3d, 0xdf, 0xd1, 0xf4, 0x97, 0x45, 0x67, 0xf7, 0x13, 0x1f, 0x74, 0xd2,
	0x7e, 0xc7, 0xfc, 0x6f, 0x27, 0x7b, 0x04, 0x27, 0x15, 0xe6, 0x79, 0x7a, 0xad, 0xa9, 0xd2, 0xa9,
	0x55, 0x92, 0x1f, 0x79, 0xed, 0x61, 0xcd, 0xbe, 0xad, 0xc9, 0x2b, 0x25, 0xe3, 0x5f, 0x1d, 0x88,
	0x82, 0xca, 0x47, 0x8b, 0xe6, 0xff, 0x5a, 0x9c, 0xc0, 0xad, 0x52, 0x58, 0x5b, 0x91, 0x91, 0xbc,
	0xe7, 0x55, 0xb7, 0x38, 0x96, 0x30, 0x7a, 0xbf, 0x59, 0x9c, 0x37, 0xda, 0xa1, 0x59, 0x88, 0x0c,
	0xeb, 0x99, 0x86, 0x65, 0x0a, 0xfe, 0x1a, 0xc8, 0x5e, 0xc0, 0xed, 0x85, 0xfa, 0x8e, 0x32, 0x15,
	0x52, 0x1a, 0xb4, 0xd6, 0x9b, 0x8c, 0xce, 0xc6, 0x89, 0x46, 0x97, 0xbc, 0xaa, 0x2b, 0xe7, 0x9b,
	0xc2, 0x7c, 0xb8, 0xd8, 0x41, 0xf1, 0xcf, 0x2e, 0x9c, 0x04, 0x87, 0xef, 0xc2, 0x50, 0xf7, 0x25,
	0xf0, 0x8f, 0xef, 0x7b, 0x02, 0xe3, 0x25, 0x59, 0x97, 0x86, 0x7d, 0x49, 0xdd, 0xba, 0xc4, 0x30,
	0x85, 0x3b, 0x75, 0x21, 0x5c, 0xf9, 0x61, 0x5d, 0x62, 0xbd, 0xc7, 0x39, 0x65, 0x22, 0xc7, 0x90,
	0x44, 0x40, 0x75, 0x46, 0x4e, 0x15, 0xf8, 0x83, 0x34, 0xf2, 0xfe, 0x26, 0xa3, 0x06, 0xb3, 0x19,
	0x8c, 0x43, 0x00, 0xa9, 0x6a, 0x42, 0xe2, 0x83, 0xe9, 0xe1, 0x8e, 0xbd, 0x76, 0x86, 0xf3, 0x91,
	0x6e, 0x31, 0x17, 0x83, 0xcf, 0x3d, 0xff, 0xa3, 0x7e, 0xe9, 0xfb, 0x3f, 0xf4, 0xd9, 0x9f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x3b, 0xd5, 0x14, 0xc3, 0xeb, 0x03, 0x00, 0x00,
}
