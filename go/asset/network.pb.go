// Code generated by protoc-gen-go.
// source: schema/asset/network.proto
// DO NOT EDIT!

package asset

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "chromium.googlesource.com/enterprise/cel/go/common"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// List of web protocols. Not necessarily exhaustive. We just need a convenient
// enum so that we don't need to defined it everywhere. Values should be self
// explanatory.
type Protocol int32

const (
	Protocol_UNKNOWN Protocol = 0
	Protocol_HTTP    Protocol = 1
	Protocol_HTTPS   Protocol = 2
)

var Protocol_name = map[int32]string{
	0: "UNKNOWN",
	1: "HTTP",
	2: "HTTPS",
}
var Protocol_value = map[string]int32{
	"UNKNOWN": 0,
	"HTTP":    1,
	"HTTPS":   2,
}

func (x Protocol) String() string {
	return proto.EnumName(Protocol_name, int32(x))
}
func (Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

type Network struct {
	// Name of the network.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The address range assigned to the network. If left unspecified, an address
	// range will be determined when deploying the assets. This is the preferred
	// option unless an explicit address range is required.
	//
	// Two networks in the same asset manifest can't have overlapping address
	// ranges even if they aren't peers.
	AddressRange *AddressRange `protobuf:"bytes,2,opt,name=address_range,json=addressRange" json:"address_range,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *Network) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Network) GetAddressRange() *AddressRange {
	if m != nil {
		return m.AddressRange
	}
	return nil
}

// NetworkPeer describes a peering group. All networks that are a member of a
// peering group can route traffic across each other.
type NetworkPeer struct {
	// List of networks that should form a full mesh. Individual networks are
	// isolated by default and are only able to talk to each other if:
	//   * They are a part of a peering group, or
	//   * They are connected via a VPN gateway, or
	//   * They are connected via a [virtual] router.
	//
	// A single nework can participate in multiple disjoint peering groups,
	// however peering is not transitive. I.e. If {A,B} is a peering group, and
	// {B,C} is a peering group, traffic from A still can't route to C.
	Network []string `protobuf:"bytes,1,rep,name=network" json:"network,omitempty"`
}

func (m *NetworkPeer) Reset()                    { *m = NetworkPeer{} }
func (m *NetworkPeer) String() string            { return proto.CompactTextString(m) }
func (*NetworkPeer) ProtoMessage()               {}
func (*NetworkPeer) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *NetworkPeer) GetNetwork() []string {
	if m != nil {
		return m.Network
	}
	return nil
}

// Address is an IPv4 or IPv6 address.
type Address struct {
	Ip string `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *Address) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

// AddressRange is an IPv4 or IPv6 CIDR range.
type AddressRange struct {
	Cidr string `protobuf:"bytes,1,opt,name=cidr" json:"cidr,omitempty"`
}

func (m *AddressRange) Reset()                    { *m = AddressRange{} }
func (m *AddressRange) String() string            { return proto.CompactTextString(m) }
func (*AddressRange) ProtoMessage()               {}
func (*AddressRange) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

func (m *AddressRange) GetCidr() string {
	if m != nil {
		return m.Cidr
	}
	return ""
}

// FixedAddress described an address that is determined either by the host
// environment or by the asset manifest.
type FixedAddress struct {
	// Types that are valid to be assigned to AddressType:
	//	*FixedAddress_Address
	//	*FixedAddress_AddressPool
	AddressType isFixedAddress_AddressType `protobuf_oneof:"address_type"`
	// Upon resolution, this field will contain the actual IP address that's
	// assigned to this network interface.
	ResolvedAddress *Address `protobuf:"bytes,3,opt,name=resolved_address,json=resolvedAddress" json:"resolved_address,omitempty"`
}

func (m *FixedAddress) Reset()                    { *m = FixedAddress{} }
func (m *FixedAddress) String() string            { return proto.CompactTextString(m) }
func (*FixedAddress) ProtoMessage()               {}
func (*FixedAddress) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{4} }

type isFixedAddress_AddressType interface {
	isFixedAddress_AddressType()
}

type FixedAddress_Address struct {
	Address *Address `protobuf:"bytes,1,opt,name=address,oneof"`
}
type FixedAddress_AddressPool struct {
	AddressPool string `protobuf:"bytes,2,opt,name=address_pool,json=addressPool,oneof"`
}

func (*FixedAddress_Address) isFixedAddress_AddressType()     {}
func (*FixedAddress_AddressPool) isFixedAddress_AddressType() {}

func (m *FixedAddress) GetAddressType() isFixedAddress_AddressType {
	if m != nil {
		return m.AddressType
	}
	return nil
}

func (m *FixedAddress) GetAddress() *Address {
	if x, ok := m.GetAddressType().(*FixedAddress_Address); ok {
		return x.Address
	}
	return nil
}

func (m *FixedAddress) GetAddressPool() string {
	if x, ok := m.GetAddressType().(*FixedAddress_AddressPool); ok {
		return x.AddressPool
	}
	return ""
}

func (m *FixedAddress) GetResolvedAddress() *Address {
	if m != nil {
		return m.ResolvedAddress
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FixedAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FixedAddress_OneofMarshaler, _FixedAddress_OneofUnmarshaler, _FixedAddress_OneofSizer, []interface{}{
		(*FixedAddress_Address)(nil),
		(*FixedAddress_AddressPool)(nil),
	}
}

func _FixedAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FixedAddress)
	// address_type
	switch x := m.AddressType.(type) {
	case *FixedAddress_Address:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Address); err != nil {
			return err
		}
	case *FixedAddress_AddressPool:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.AddressPool)
	case nil:
	default:
		return fmt.Errorf("FixedAddress.AddressType has unexpected type %T", x)
	}
	return nil
}

func _FixedAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FixedAddress)
	switch tag {
	case 1: // address_type.address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Address)
		err := b.DecodeMessage(msg)
		m.AddressType = &FixedAddress_Address{msg}
		return true, err
	case 2: // address_type.address_pool
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AddressType = &FixedAddress_AddressPool{x}
		return true, err
	default:
		return false, nil
	}
}

func _FixedAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FixedAddress)
	// address_type
	switch x := m.AddressType.(type) {
	case *FixedAddress_Address:
		s := proto.Size(x.Address)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FixedAddress_AddressPool:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.AddressPool)))
		n += len(x.AddressPool)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Network)(nil), "asset.Network")
	proto.RegisterType((*NetworkPeer)(nil), "asset.NetworkPeer")
	proto.RegisterType((*Address)(nil), "asset.Address")
	proto.RegisterType((*AddressRange)(nil), "asset.AddressRange")
	proto.RegisterType((*FixedAddress)(nil), "asset.FixedAddress")
	proto.RegisterEnum("asset.Protocol", Protocol_name, Protocol_value)
}

func init() { proto.RegisterFile("schema/asset/network.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 398 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0xcf, 0x6e, 0x9b, 0x40,
	0x10, 0xc6, 0x0d, 0x71, 0x82, 0x19, 0x9c, 0x84, 0xae, 0xa5, 0x16, 0xb9, 0x17, 0x97, 0x93, 0x65,
	0xb5, 0xa0, 0x26, 0x97, 0x1e, 0x72, 0x09, 0x87, 0xca, 0x52, 0x25, 0x8a, 0xb6, 0xa9, 0x22, 0xf5,
	0x62, 0xd1, 0x65, 0x84, 0x51, 0x81, 0x41, 0xbb, 0xb8, 0x7f, 0xae, 0x7e, 0x27, 0x3f, 0x45, 0x5f,
	0xaa, 0x32, 0x2c, 0xaa, 0x5b, 0xe5, 0xb6, 0x3b, 0xdf, 0x8f, 0x6f, 0xbe, 0x61, 0x07, 0xe6, 0x4a,
	0x6c, 0xb1, 0x4a, 0xc3, 0x54, 0x29, 0x6c, 0xc3, 0x1a, 0xdb, 0x1f, 0x24, 0xbf, 0x05, 0x8d, 0xa4,
	0x96, 0xd8, 0x79, 0x57, 0x9c, 0xbf, 0xd4, 0x88, 0xa0, 0xaa, 0xa2, 0x3a, 0xa4, 0xa6, 0x2d, 0xa8,
	0x56, 0x3d, 0xe3, 0x3f, 0x82, 0x15, 0xf7, 0x1f, 0x31, 0x06, 0xe3, 0x3a, 0xad, 0xd0, 0x33, 0x16,
	0xc6, 0xd2, 0xe6, 0xdd, 0x99, 0xbd, 0x83, 0xcb, 0x34, 0xcb, 0x24, 0x2a, 0xb5, 0x91, 0x69, 0x9d,
	0xa3, 0x67, 0x2e, 0x8c, 0xa5, 0x73, 0x33, 0x0b, 0x3a, 0xeb, 0xe0, 0xbe, 0xd7, 0xf8, 0x51, 0xe2,
	0xd3, 0xf4, 0xe4, 0xe6, 0xdf, 0x81, 0xa3, 0x8d, 0x13, 0x44, 0xc9, 0xde, 0x80, 0xa5, 0xc3, 0x79,
	0xc6, 0xe2, 0x6c, 0x69, 0x47, 0xb3, 0xfd, 0xc1, 0xbb, 0x66, 0x97, 0xbd, 0x8f, 0x96, 0xf8, 0xc0,
	0xf8, 0xaf, 0xc0, 0xd2, 0xde, 0xec, 0x39, 0x98, 0x45, 0xd3, 0x87, 0x8a, 0x2e, 0xf6, 0x07, 0xcf,
	0x9c, 0x18, 0xdc, 0x2c, 0x1a, 0x7f, 0x05, 0xd3, 0xd3, 0xf6, 0x6c, 0x0e, 0x63, 0x51, 0x64, 0xf2,
	0x3f, 0xb2, 0xab, 0xf9, 0xbf, 0x0d, 0x98, 0xbe, 0x2f, 0x7e, 0x62, 0x36, 0x98, 0xae, 0xc0, 0xd2,
	0x69, 0x3b, 0xde, 0xb9, 0xb9, 0xfa, 0x77, 0xa2, 0xf5, 0x88, 0x0f, 0x00, 0xbb, 0x83, 0x61, 0xb2,
	0x4d, 0x43, 0x54, 0x76, 0xbf, 0xc0, 0x8e, 0x5e, 0xec, 0x0f, 0xde, 0x8c, 0x3d, 0xdb, 0x92, 0x6a,
	0x83, 0x53, 0x79, 0x3d, 0xe2, 0x8e, 0xbe, 0x27, 0x44, 0x25, 0xbb, 0x07, 0x57, 0xa2, 0xa2, 0xf2,
	0x3b, 0x66, 0x9b, 0xa1, 0xe5, 0xd9, 0x53, 0x2d, 0x75, 0x64, 0x93, 0x5f, 0x0f, 0xfc, 0x20, 0x5c,
	0xfd, 0x0d, 0xd0, 0xfe, 0x6a, 0x70, 0xf5, 0x1a, 0x26, 0xc9, 0xf1, 0xf1, 0x04, 0x95, 0xcc, 0x01,
	0xeb, 0x73, 0xfc, 0x21, 0xfe, 0xf8, 0x18, 0xbb, 0x23, 0x36, 0x81, 0xf1, 0xfa, 0xe1, 0x21, 0x71,
	0x0d, 0x66, 0xc3, 0xf9, 0xf1, 0xf4, 0xc9, 0x35, 0xa3, 0xdb, 0x2f, 0x6f, 0xc5, 0x56, 0x52, 0x55,
	0xec, 0xaa, 0x20, 0x27, 0xca, 0x4b, 0x54, 0xb4, 0x93, 0x02, 0x03, 0x41, 0x55, 0x88, 0x75, 0x8b,
	0xb2, 0x91, 0x85, 0xc2, 0x50, 0x60, 0x19, 0xe6, 0xd4, 0x2f, 0xd2, 0xd7, 0x8b, 0x6e, 0x3b, 0x6e,
	0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xb8, 0xec, 0x95, 0x43, 0x5f, 0x02, 0x00, 0x00,
}
