// Code generated by protoc-gen-go.
// source: schema/asset/active_directory.proto
// DO NOT EDIT!

/*
Package asset is a generated protocol buffer package.

It is generated from these files:
	schema/asset/active_directory.proto
	schema/asset/cert.proto
	schema/asset/dns.proto
	schema/asset/iis.proto
	schema/asset/network.proto
	schema/asset/asset_manifest.proto

It has these top-level messages:
	ActiveDirectoryDomain
	ActiveDirectoryDomainController
	ActiveDirectoryOrganizationalUnit
	ActiveDirectoryGroupPolicy
	ActiveDirectoryGroupPolicyLink
	ActiveDirectoryRegistryPolicy
	ActiveDirectoryRegistryPrefPolicy
	RegistryKey
	RegistryValue
	WindowsContainer
	WindowsGroup
	GroupReference
	UserReference
	UserOrGroupReference
	WindowsUser
	NetworkInterface
	WindowsMachine
	Certificate
	CertificatePool
	DNSZone
	DNSRecord
	IISServer
	IISBindings
	IISSite
	IISApplication
	Network
	NetworkPeer
	Address
	AddressRange
	FixedAddress
	AssetManifest
*/
package asset

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common1 "chromium.googlesource.com/enterprise/cel/go/common"
import _ "chromium.googlesource.com/enterprise/cel/go/common"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Type of registry values. The default is STRING.
type RegistryValueType int32

const (
	RegistryValueType_STRING        RegistryValueType = 0
	RegistryValueType_EXPAND_STRING RegistryValueType = 1
	RegistryValueType_BINARY        RegistryValueType = 2
	RegistryValueType_DWORD         RegistryValueType = 3
	RegistryValueType_MULTI_STRING  RegistryValueType = 4
	RegistryValueType_QWORD         RegistryValueType = 5
)

var RegistryValueType_name = map[int32]string{
	0: "STRING",
	1: "EXPAND_STRING",
	2: "BINARY",
	3: "DWORD",
	4: "MULTI_STRING",
	5: "QWORD",
}
var RegistryValueType_value = map[string]int32{
	"STRING":        0,
	"EXPAND_STRING": 1,
	"BINARY":        2,
	"DWORD":         3,
	"MULTI_STRING":  4,
	"QWORD":         5,
}

func (x RegistryValueType) String() string {
	return proto.EnumName(RegistryValueType_name, int32(x))
}
func (RegistryValueType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Active Directory functional level. A.k.a. Domain Mode. See
// https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/active-directory-functional-levels
// for more details on the specific features that are available at each
// functional level.
type ActiveDirectoryDomain_Mode int32

const (
	// Use the default. The default functional level depends on the host OS and
	// on the other AD DS servers in the domain or forest.
	ActiveDirectoryDomain_DEFAULT   ActiveDirectoryDomain_Mode = 0
	ActiveDirectoryDomain_Win2003   ActiveDirectoryDomain_Mode = 2
	ActiveDirectoryDomain_Win2008   ActiveDirectoryDomain_Mode = 3
	ActiveDirectoryDomain_Win2008R2 ActiveDirectoryDomain_Mode = 4
	ActiveDirectoryDomain_Win2012   ActiveDirectoryDomain_Mode = 5
	ActiveDirectoryDomain_Win2012R2 ActiveDirectoryDomain_Mode = 6
	ActiveDirectoryDomain_Win2016   ActiveDirectoryDomain_Mode = 7
)

var ActiveDirectoryDomain_Mode_name = map[int32]string{
	0: "DEFAULT",
	2: "Win2003",
	3: "Win2008",
	4: "Win2008R2",
	5: "Win2012",
	6: "Win2012R2",
	7: "Win2016",
}
var ActiveDirectoryDomain_Mode_value = map[string]int32{
	"DEFAULT":   0,
	"Win2003":   2,
	"Win2008":   3,
	"Win2008R2": 4,
	"Win2012":   5,
	"Win2012R2": 6,
	"Win2016":   7,
}

func (x ActiveDirectoryDomain_Mode) String() string {
	return proto.EnumName(ActiveDirectoryDomain_Mode_name, int32(x))
}
func (ActiveDirectoryDomain_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0}
}

// Domain type
type ActiveDirectoryDomain_Type int32

const (
	// Child of an existing domain. (This is the default)
	ActiveDirectoryDomain_CHILD ActiveDirectoryDomain_Type = 0
	// Root of a new domain tree.
	ActiveDirectoryDomain_TREE ActiveDirectoryDomain_Type = 1
)

var ActiveDirectoryDomain_Type_name = map[int32]string{
	0: "CHILD",
	1: "TREE",
}
var ActiveDirectoryDomain_Type_value = map[string]int32{
	"CHILD": 0,
	"TREE":  1,
}

func (x ActiveDirectoryDomain_Type) String() string {
	return proto.EnumName(ActiveDirectoryDomain_Type_name, int32(x))
}
func (ActiveDirectoryDomain_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 1}
}

// The action to take when processing the GPO.
type ActiveDirectoryRegistryPrefPolicy_Action int32

const (
	ActiveDirectoryRegistryPrefPolicy_CREATE  ActiveDirectoryRegistryPrefPolicy_Action = 0
	ActiveDirectoryRegistryPrefPolicy_REPLACE ActiveDirectoryRegistryPrefPolicy_Action = 1
	ActiveDirectoryRegistryPrefPolicy_UPDATE  ActiveDirectoryRegistryPrefPolicy_Action = 2
	ActiveDirectoryRegistryPrefPolicy_DELETE  ActiveDirectoryRegistryPrefPolicy_Action = 3
)

var ActiveDirectoryRegistryPrefPolicy_Action_name = map[int32]string{
	0: "CREATE",
	1: "REPLACE",
	2: "UPDATE",
	3: "DELETE",
}
var ActiveDirectoryRegistryPrefPolicy_Action_value = map[string]int32{
	"CREATE":  0,
	"REPLACE": 1,
	"UPDATE":  2,
	"DELETE":  3,
}

func (x ActiveDirectoryRegistryPrefPolicy_Action) String() string {
	return proto.EnumName(ActiveDirectoryRegistryPrefPolicy_Action_name, int32(x))
}
func (ActiveDirectoryRegistryPrefPolicy_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0}
}

// Describes an Active Directory domain or forest.
type ActiveDirectoryDomain struct {
	// FQDN of the domain in lower case.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Parent domain name. Only specify this if this domain is going to be a
	// child domain.
	ParentName string                     `protobuf:"bytes,2,opt,name=parent_name,json=parentName" json:"parent_name,omitempty"`
	DomainMode ActiveDirectoryDomain_Mode `protobuf:"varint,3,opt,name=domain_mode,json=domainMode,enum=asset.ActiveDirectoryDomain_Mode" json:"domain_mode,omitempty"`
	// NetBIOS name. Required if |name| is longer than 15 characters.
	NetbiosName string                     `protobuf:"bytes,4,opt,name=netbios_name,json=netbiosName" json:"netbios_name,omitempty"`
	Type        ActiveDirectoryDomain_Type `protobuf:"varint,5,opt,name=type,enum=asset.ActiveDirectoryDomain_Type" json:"type,omitempty"`
	// Forest functional level (only applicable when creating a new forest.
	ForestMode ActiveDirectoryDomain_Mode `protobuf:"varint,6,opt,name=forest_mode,json=forestMode,enum=asset.ActiveDirectoryDomain_Mode" json:"forest_mode,omitempty"`
}

func (m *ActiveDirectoryDomain) Reset()                    { *m = ActiveDirectoryDomain{} }
func (m *ActiveDirectoryDomain) String() string            { return proto.CompactTextString(m) }
func (*ActiveDirectoryDomain) ProtoMessage()               {}
func (*ActiveDirectoryDomain) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ActiveDirectoryDomain) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActiveDirectoryDomain) GetParentName() string {
	if m != nil {
		return m.ParentName
	}
	return ""
}

func (m *ActiveDirectoryDomain) GetDomainMode() ActiveDirectoryDomain_Mode {
	if m != nil {
		return m.DomainMode
	}
	return ActiveDirectoryDomain_DEFAULT
}

func (m *ActiveDirectoryDomain) GetNetbiosName() string {
	if m != nil {
		return m.NetbiosName
	}
	return ""
}

func (m *ActiveDirectoryDomain) GetType() ActiveDirectoryDomain_Type {
	if m != nil {
		return m.Type
	}
	return ActiveDirectoryDomain_CHILD
}

func (m *ActiveDirectoryDomain) GetForestMode() ActiveDirectoryDomain_Mode {
	if m != nil {
		return m.ForestMode
	}
	return ActiveDirectoryDomain_DEFAULT
}

// Describes a single Active Directory Domain Controller.
type ActiveDirectoryDomainController struct {
	// Name of the domain. Must match the `name` field of an
	// ActiveDirectoryDomain entry.
	AdDomain string `protobuf:"bytes,1,opt,name=ad_domain,json=adDomain" json:"ad_domain,omitempty"`
	// Machine hosting the ADDS. Must match the `name` of a WindowsMachine entry.
	WindowsMachine string `protobuf:"bytes,2,opt,name=windows_machine,json=windowsMachine" json:"windows_machine,omitempty"`
	// Whether or not to install a DNS server on this machine. The default is
	// almost always |true| unless the domain already exists and the existing
	// domain controller does not host a DNS server.
	//
	// Don't specify the option if you would like the domain controller to do the
	// default action. Or specify it to force one or the other.
	//
	// Types that are valid to be assigned to OptionalDns:
	//	*ActiveDirectoryDomainController_InstallDns
	OptionalDns isActiveDirectoryDomainController_OptionalDns `protobuf_oneof:"optional_dns"`
	// Assume DNS service is not available on the network. Only applicable when
	// installing DNS services. If this field is not set, or set to false, then
	// the installation can assume that the TCP/IP client settings of the host OS
	// specifies the DNS server to use.
	NoDnsOnNetwork bool `protobuf:"varint,4,opt,name=no_dns_on_network,json=noDnsOnNetwork" json:"no_dns_on_network,omitempty"`
	// This domain controller should not be a global catalog server. Default is
	// to run with global catalog for Win2012 or later.
	NoGlobalCatalog bool `protobuf:"varint,5,opt,name=no_global_catalog,json=noGlobalCatalog" json:"no_global_catalog,omitempty"`
	// If true, attempts to create a DNS delegation for the new DNS server. Only
	// applicable when installing a DNS server. E.g.: If the authoritative DNS
	// server for foo.example.com is using ActiveDirectory, and we are installing
	// the subordinate domain bar, then setting this value to true causes
	// foo.example.com to delegate the bar domain to the new DNS server.
	CreateDnsDelegation bool `protobuf:"varint,6,opt,name=create_dns_delegation,json=createDnsDelegation" json:"create_dns_delegation,omitempty"`
}

func (m *ActiveDirectoryDomainController) Reset()                    { *m = ActiveDirectoryDomainController{} }
func (m *ActiveDirectoryDomainController) String() string            { return proto.CompactTextString(m) }
func (*ActiveDirectoryDomainController) ProtoMessage()               {}
func (*ActiveDirectoryDomainController) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isActiveDirectoryDomainController_OptionalDns interface {
	isActiveDirectoryDomainController_OptionalDns()
}

type ActiveDirectoryDomainController_InstallDns struct {
	InstallDns bool `protobuf:"varint,3,opt,name=install_dns,json=installDns,oneof"`
}

func (*ActiveDirectoryDomainController_InstallDns) isActiveDirectoryDomainController_OptionalDns() {}

func (m *ActiveDirectoryDomainController) GetOptionalDns() isActiveDirectoryDomainController_OptionalDns {
	if m != nil {
		return m.OptionalDns
	}
	return nil
}

func (m *ActiveDirectoryDomainController) GetAdDomain() string {
	if m != nil {
		return m.AdDomain
	}
	return ""
}

func (m *ActiveDirectoryDomainController) GetWindowsMachine() string {
	if m != nil {
		return m.WindowsMachine
	}
	return ""
}

func (m *ActiveDirectoryDomainController) GetInstallDns() bool {
	if x, ok := m.GetOptionalDns().(*ActiveDirectoryDomainController_InstallDns); ok {
		return x.InstallDns
	}
	return false
}

func (m *ActiveDirectoryDomainController) GetNoDnsOnNetwork() bool {
	if m != nil {
		return m.NoDnsOnNetwork
	}
	return false
}

func (m *ActiveDirectoryDomainController) GetNoGlobalCatalog() bool {
	if m != nil {
		return m.NoGlobalCatalog
	}
	return false
}

func (m *ActiveDirectoryDomainController) GetCreateDnsDelegation() bool {
	if m != nil {
		return m.CreateDnsDelegation
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ActiveDirectoryDomainController) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ActiveDirectoryDomainController_OneofMarshaler, _ActiveDirectoryDomainController_OneofUnmarshaler, _ActiveDirectoryDomainController_OneofSizer, []interface{}{
		(*ActiveDirectoryDomainController_InstallDns)(nil),
	}
}

func _ActiveDirectoryDomainController_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ActiveDirectoryDomainController)
	// optional_dns
	switch x := m.OptionalDns.(type) {
	case *ActiveDirectoryDomainController_InstallDns:
		t := uint64(0)
		if x.InstallDns {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ActiveDirectoryDomainController.OptionalDns has unexpected type %T", x)
	}
	return nil
}

func _ActiveDirectoryDomainController_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ActiveDirectoryDomainController)
	switch tag {
	case 3: // optional_dns.install_dns
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.OptionalDns = &ActiveDirectoryDomainController_InstallDns{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ActiveDirectoryDomainController_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ActiveDirectoryDomainController)
	// optional_dns
	switch x := m.OptionalDns.(type) {
	case *ActiveDirectoryDomainController_InstallDns:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Describes an Active Directory Organizational Unit.
//
// Note that this message omits location properties like postal code, city,
// state, and country. Use the 'property' field to specify these if required.
//
// E.g.:
//     ad_organizational_unit {
//        name: 'foo'
//        ...
//        property { key: 'l', value: 'Cambridge' }
//        property { key: 'st', value: 'MA' }
//        ..
//     }
type ActiveDirectoryOrganizationalUnit struct {
	// Name of the OU. Also populates the 'name' property of the AD object unless
	// overridden by |full_name|.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The 'name' property of the AD object. Only specify this if |name| can't be
	// used to store the display name.
	FullName string `protobuf:"bytes,2,opt,name=full_name,json=fullName" json:"full_name,omitempty"`
	// The container in which this OU is created. Only the 'ad_domain' and
	// 'ad_organizational_unit' values are valid.
	Container *WindowsContainer `protobuf:"bytes,3,opt,name=container" json:"container,omitempty"`
	// The AD DS server which should service the request for creating the OU if
	// necessary. If left unspecified, any of the candidate AD DS instances
	// associated with 'container' will be used.
	Server string `protobuf:"bytes,4,opt,name=server" json:"server,omitempty"`
	// Use the referred AD OU as the template. Any properties specified in this
	// message will override corresponding properties from the template OU. Any
	// properties specified in the template, but not in this message will be
	// copied over.
	BasedOn string `protobuf:"bytes,5,opt,name=based_on,json=basedOn" json:"based_on,omitempty"`
	// The 'displayName' property of the AD object.
	DisplayName string `protobuf:"bytes,6,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// The 'description' property of the AD object.
	Description string `protobuf:"bytes,7,opt,name=description" json:"description,omitempty"`
	// The principal managing this OU. Note that the 'container' property for a
	// user or a group is implicit and should be omitted.
	ManagedBy *UserOrGroupReference `protobuf:"bytes,8,opt,name=managed_by,json=managedBy" json:"managed_by,omitempty"`
	// Additional properties. The key is the ldapDisplayName of the property. The
	// value can be a single string. Repeat using the same key to specify more
	// than one value for a single key.
	//
	// E.g.:
	//     property {
	//       key: 'favColors'
	//       value: 'pink'
	//     }
	//
	//     property {
	//       key: 'favColors'
	//       value: 'purple'
	//     }
	Property map[string]string `protobuf:"bytes,9,rep,name=property" json:"property,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ActiveDirectoryOrganizationalUnit) Reset()         { *m = ActiveDirectoryOrganizationalUnit{} }
func (m *ActiveDirectoryOrganizationalUnit) String() string { return proto.CompactTextString(m) }
func (*ActiveDirectoryOrganizationalUnit) ProtoMessage()    {}
func (*ActiveDirectoryOrganizationalUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2}
}

func (m *ActiveDirectoryOrganizationalUnit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActiveDirectoryOrganizationalUnit) GetFullName() string {
	if m != nil {
		return m.FullName
	}
	return ""
}

func (m *ActiveDirectoryOrganizationalUnit) GetContainer() *WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ActiveDirectoryOrganizationalUnit) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *ActiveDirectoryOrganizationalUnit) GetBasedOn() string {
	if m != nil {
		return m.BasedOn
	}
	return ""
}

func (m *ActiveDirectoryOrganizationalUnit) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ActiveDirectoryOrganizationalUnit) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ActiveDirectoryOrganizationalUnit) GetManagedBy() *UserOrGroupReference {
	if m != nil {
		return m.ManagedBy
	}
	return nil
}

func (m *ActiveDirectoryOrganizationalUnit) GetProperty() map[string]string {
	if m != nil {
		return m.Property
	}
	return nil
}

// Describes an Active Directory GPO. The GPO itself may not contain anything
// particularly important on creation, and is entirely based on the starter
// GPO. The GPO is also not linked anywhere by default. Use the
// ActiveDirectoryGroupPolicyLink message to create links, and
// ActiveDirectoryRegistryPolicy to add registry based policies.
//
// E.g.:
//
//     # Create a group policy.
//     ad_group_policy {
//       name: 'foo'
//       ad_domain: 'my-domain'
//     }
//
//     # Add some registry values to it.
//     ad_registry_policy {
//       name: 'reg-pol-0001'
//       ad_group_policy: 'foo'
//
//       key {
//         path: 'HKCU\\Software\\My Company\\Foo\\Bar'
//
//         value {
//           name: 'version'
//           value: '1.0'
//         }
//
//         value {
//           name: 'FooCount'
//           type: DWORD
//           value: '10'
//         }
//       }
//     }
//
//     # And link it to one or more OUs.
//     ad_group_policy_link {
//       name: 'foo-link'
//       ad_group_policy: 'foo'
//       container { ad_organizational_unit: 'my-ou' }
//       container { ad_organizational_unit: 'your-ou' }
//       enforced: true
//     }
type ActiveDirectoryGroupPolicy struct {
	// The name of the GPO.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The full name. Only use this if the full name cannot be specified in |name|.
	FullName string `protobuf:"bytes,2,opt,name=full_name,json=fullName" json:"full_name,omitempty"`
	// The domain in which this GPO is created.
	AdDomain string `protobuf:"bytes,3,opt,name=ad_domain,json=adDomain" json:"ad_domain,omitempty"`
	// A comment for the GPO. This can contain up to 2047 characters.
	Comment string `protobuf:"bytes,4,opt,name=comment" json:"comment,omitempty"`
	// If a template GPO is specified, that will be used as the starter GPO.
	// Creates a starter GPO is no value is specified here.
	BasedOn string `protobuf:"bytes,5,opt,name=based_on,json=basedOn" json:"based_on,omitempty"`
}

func (m *ActiveDirectoryGroupPolicy) Reset()                    { *m = ActiveDirectoryGroupPolicy{} }
func (m *ActiveDirectoryGroupPolicy) String() string            { return proto.CompactTextString(m) }
func (*ActiveDirectoryGroupPolicy) ProtoMessage()               {}
func (*ActiveDirectoryGroupPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ActiveDirectoryGroupPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActiveDirectoryGroupPolicy) GetFullName() string {
	if m != nil {
		return m.FullName
	}
	return ""
}

func (m *ActiveDirectoryGroupPolicy) GetAdDomain() string {
	if m != nil {
		return m.AdDomain
	}
	return ""
}

func (m *ActiveDirectoryGroupPolicy) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *ActiveDirectoryGroupPolicy) GetBasedOn() string {
	if m != nil {
		return m.BasedOn
	}
	return ""
}

// Describes one or more GPO links.
type ActiveDirectoryGroupPolicyLink struct {
	// A convenient identifier for this set of GPO links.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The policy that will be linked.
	AdGroupPolicy string `protobuf:"bytes,2,opt,name=ad_group_policy,json=adGroupPolicy" json:"ad_group_policy,omitempty"`
	// The list of containers for which the GPO referred to in |ad_group_policy|
	// will be linked. Only the |ad_domain| and |ad_organizational_unit| fields
	// can be used. There should be at least one of these.
	Container []*WindowsContainer `protobuf:"bytes,3,rep,name=container" json:"container,omitempty"`
	// If specified, sets the enforced state for the GPO links.
	//
	// Types that are valid to be assigned to OptionalEnforce:
	//	*ActiveDirectoryGroupPolicyLink_Enforced
	OptionalEnforce isActiveDirectoryGroupPolicyLink_OptionalEnforce `protobuf_oneof:"optional_enforce"`
	// If specified, sets the enabled state for the GPO links.
	//
	// Types that are valid to be assigned to OptionalEnabled:
	//	*ActiveDirectoryGroupPolicyLink_Enabled
	OptionalEnabled isActiveDirectoryGroupPolicyLink_OptionalEnabled `protobuf_oneof:"optional_enabled"`
}

func (m *ActiveDirectoryGroupPolicyLink) Reset()                    { *m = ActiveDirectoryGroupPolicyLink{} }
func (m *ActiveDirectoryGroupPolicyLink) String() string            { return proto.CompactTextString(m) }
func (*ActiveDirectoryGroupPolicyLink) ProtoMessage()               {}
func (*ActiveDirectoryGroupPolicyLink) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isActiveDirectoryGroupPolicyLink_OptionalEnforce interface {
	isActiveDirectoryGroupPolicyLink_OptionalEnforce()
}
type isActiveDirectoryGroupPolicyLink_OptionalEnabled interface {
	isActiveDirectoryGroupPolicyLink_OptionalEnabled()
}

type ActiveDirectoryGroupPolicyLink_Enforced struct {
	Enforced bool `protobuf:"varint,4,opt,name=enforced,oneof"`
}
type ActiveDirectoryGroupPolicyLink_Enabled struct {
	Enabled bool `protobuf:"varint,5,opt,name=enabled,oneof"`
}

func (*ActiveDirectoryGroupPolicyLink_Enforced) isActiveDirectoryGroupPolicyLink_OptionalEnforce() {}
func (*ActiveDirectoryGroupPolicyLink_Enabled) isActiveDirectoryGroupPolicyLink_OptionalEnabled()  {}

func (m *ActiveDirectoryGroupPolicyLink) GetOptionalEnforce() isActiveDirectoryGroupPolicyLink_OptionalEnforce {
	if m != nil {
		return m.OptionalEnforce
	}
	return nil
}
func (m *ActiveDirectoryGroupPolicyLink) GetOptionalEnabled() isActiveDirectoryGroupPolicyLink_OptionalEnabled {
	if m != nil {
		return m.OptionalEnabled
	}
	return nil
}

func (m *ActiveDirectoryGroupPolicyLink) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActiveDirectoryGroupPolicyLink) GetAdGroupPolicy() string {
	if m != nil {
		return m.AdGroupPolicy
	}
	return ""
}

func (m *ActiveDirectoryGroupPolicyLink) GetContainer() []*WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ActiveDirectoryGroupPolicyLink) GetEnforced() bool {
	if x, ok := m.GetOptionalEnforce().(*ActiveDirectoryGroupPolicyLink_Enforced); ok {
		return x.Enforced
	}
	return false
}

func (m *ActiveDirectoryGroupPolicyLink) GetEnabled() bool {
	if x, ok := m.GetOptionalEnabled().(*ActiveDirectoryGroupPolicyLink_Enabled); ok {
		return x.Enabled
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ActiveDirectoryGroupPolicyLink) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ActiveDirectoryGroupPolicyLink_OneofMarshaler, _ActiveDirectoryGroupPolicyLink_OneofUnmarshaler, _ActiveDirectoryGroupPolicyLink_OneofSizer, []interface{}{
		(*ActiveDirectoryGroupPolicyLink_Enforced)(nil),
		(*ActiveDirectoryGroupPolicyLink_Enabled)(nil),
	}
}

func _ActiveDirectoryGroupPolicyLink_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ActiveDirectoryGroupPolicyLink)
	// optional_enforce
	switch x := m.OptionalEnforce.(type) {
	case *ActiveDirectoryGroupPolicyLink_Enforced:
		t := uint64(0)
		if x.Enforced {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ActiveDirectoryGroupPolicyLink.OptionalEnforce has unexpected type %T", x)
	}
	// optional_enabled
	switch x := m.OptionalEnabled.(type) {
	case *ActiveDirectoryGroupPolicyLink_Enabled:
		t := uint64(0)
		if x.Enabled {
			t = 1
		}
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ActiveDirectoryGroupPolicyLink.OptionalEnabled has unexpected type %T", x)
	}
	return nil
}

func _ActiveDirectoryGroupPolicyLink_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ActiveDirectoryGroupPolicyLink)
	switch tag {
	case 4: // optional_enforce.enforced
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.OptionalEnforce = &ActiveDirectoryGroupPolicyLink_Enforced{x != 0}
		return true, err
	case 5: // optional_enabled.enabled
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.OptionalEnabled = &ActiveDirectoryGroupPolicyLink_Enabled{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ActiveDirectoryGroupPolicyLink_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ActiveDirectoryGroupPolicyLink)
	// optional_enforce
	switch x := m.OptionalEnforce.(type) {
	case *ActiveDirectoryGroupPolicyLink_Enforced:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// optional_enabled
	switch x := m.OptionalEnabled.(type) {
	case *ActiveDirectoryGroupPolicyLink_Enabled:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Describes a set of registry keys that should be applied for a GPO.
type ActiveDirectoryRegistryPolicy struct {
	// An identifier for the registry policy.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The GPO that will be affected by this registry policy.
	AdGroupPolicy string `protobuf:"bytes,2,opt,name=ad_group_policy,json=adGroupPolicy" json:"ad_group_policy,omitempty"`
	// If true, the registry values defined in this message will be added to the
	// respective registry keys. The default behavior -- also the behavior when
	// this field is set to false -- is to delete all the values under each key
	// prior to adding the new values.
	Additive bool `protobuf:"varint,3,opt,name=additive" json:"additive,omitempty"`
	// Set of registry keys and values that will be applied (in order).
	Key []*RegistryKey `protobuf:"bytes,4,rep,name=key" json:"key,omitempty"`
}

func (m *ActiveDirectoryRegistryPolicy) Reset()                    { *m = ActiveDirectoryRegistryPolicy{} }
func (m *ActiveDirectoryRegistryPolicy) String() string            { return proto.CompactTextString(m) }
func (*ActiveDirectoryRegistryPolicy) ProtoMessage()               {}
func (*ActiveDirectoryRegistryPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ActiveDirectoryRegistryPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActiveDirectoryRegistryPolicy) GetAdGroupPolicy() string {
	if m != nil {
		return m.AdGroupPolicy
	}
	return ""
}

func (m *ActiveDirectoryRegistryPolicy) GetAdditive() bool {
	if m != nil {
		return m.Additive
	}
	return false
}

func (m *ActiveDirectoryRegistryPolicy) GetKey() []*RegistryKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// Describes a registry change that should happen when applying a GPO.
type ActiveDirectoryRegistryPrefPolicy struct {
	// An identifier for the registry policy.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The GPO that will be affected by this registry policy.
	AdGroupPolicy string                                   `protobuf:"bytes,2,opt,name=ad_group_policy,json=adGroupPolicy" json:"ad_group_policy,omitempty"`
	Action        ActiveDirectoryRegistryPrefPolicy_Action `protobuf:"varint,3,opt,name=action,enum=asset.ActiveDirectoryRegistryPrefPolicy_Action" json:"action,omitempty"`
	// Set of registry keys and values that will be applied (in order).
	Key []*RegistryKey `protobuf:"bytes,4,rep,name=key" json:"key,omitempty"`
}

func (m *ActiveDirectoryRegistryPrefPolicy) Reset()         { *m = ActiveDirectoryRegistryPrefPolicy{} }
func (m *ActiveDirectoryRegistryPrefPolicy) String() string { return proto.CompactTextString(m) }
func (*ActiveDirectoryRegistryPrefPolicy) ProtoMessage()    {}
func (*ActiveDirectoryRegistryPrefPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6}
}

func (m *ActiveDirectoryRegistryPrefPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActiveDirectoryRegistryPrefPolicy) GetAdGroupPolicy() string {
	if m != nil {
		return m.AdGroupPolicy
	}
	return ""
}

func (m *ActiveDirectoryRegistryPrefPolicy) GetAction() ActiveDirectoryRegistryPrefPolicy_Action {
	if m != nil {
		return m.Action
	}
	return ActiveDirectoryRegistryPrefPolicy_CREATE
}

func (m *ActiveDirectoryRegistryPrefPolicy) GetKey() []*RegistryKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// A registry key.
type RegistryKey struct {
	// Path to registry key. Either backslashes or forwardslashes can be used as
	// separators. The first component of the path selects the hive. The
	// following values and aliases are accepted fas the first component of the
	// path:
	//
	//     HKEY_CLASSES_ROOT, HKCR
	//     HKEY_CURRENT_USER, HKCU
	//     HKEY_LOCAL_MACHINE, HKLM
	//     HKEY_USERS, HKU
	//     HKEY_CURRENT_CONFIG, HKCC
	//
	// E.g.:
	//     key {
	//       path: 'HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Foo\\bar'
	//       value: {
	//         name: 'x'
	//         type: STRING
	//         value: 'y'
	//       }
	//     }
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// The list of values under the key.
	Value []*RegistryValue `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
}

func (m *RegistryKey) Reset()                    { *m = RegistryKey{} }
func (m *RegistryKey) String() string            { return proto.CompactTextString(m) }
func (*RegistryKey) ProtoMessage()               {}
func (*RegistryKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *RegistryKey) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *RegistryKey) GetValue() []*RegistryValue {
	if m != nil {
		return m.Value
	}
	return nil
}

// A single registry value. The registry key is implied based on the containing
// message.
type RegistryValue struct {
	// Value name. Leave empty to set the default value.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// One of RegistryValueType.
	Type RegistryValueType `protobuf:"varint,2,opt,name=type,enum=asset.RegistryValueType" json:"type,omitempty"`
	// The value. THe format is as follows:
	//
	// STRING, EXPAND_STRING : A single 'value' with contents.
	// MULTI_STRING : Multiple 'value' entries each specifying a single string.
	// DWORD, QWORD : A number as a string. E.g.: '3', '0x
	Value []string `protobuf:"bytes,3,rep,name=value" json:"value,omitempty"`
}

func (m *RegistryValue) Reset()                    { *m = RegistryValue{} }
func (m *RegistryValue) String() string            { return proto.CompactTextString(m) }
func (*RegistryValue) ProtoMessage()               {}
func (*RegistryValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RegistryValue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegistryValue) GetType() RegistryValueType {
	if m != nil {
		return m.Type
	}
	return RegistryValueType_STRING
}

func (m *RegistryValue) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

// Describes a container that a Windows asset can reside in.
//
// Resources like machines, users, and groups can be specified per domain, per
// machine, or per organizational unit. When specifying one of these asset
// types, use the WindowsContainer member to specify where to create the asset.
type WindowsContainer struct {
	// Types that are valid to be assigned to Container:
	//	*WindowsContainer_AdDomain
	//	*WindowsContainer_WindowsMachine
	//	*WindowsContainer_AdOrganizationalUnit
	Container isWindowsContainer_Container `protobuf_oneof:"container"`
}

func (m *WindowsContainer) Reset()                    { *m = WindowsContainer{} }
func (m *WindowsContainer) String() string            { return proto.CompactTextString(m) }
func (*WindowsContainer) ProtoMessage()               {}
func (*WindowsContainer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isWindowsContainer_Container interface {
	isWindowsContainer_Container()
}

type WindowsContainer_AdDomain struct {
	AdDomain string `protobuf:"bytes,1,opt,name=ad_domain,json=adDomain,oneof"`
}
type WindowsContainer_WindowsMachine struct {
	WindowsMachine string `protobuf:"bytes,2,opt,name=windows_machine,json=windowsMachine,oneof"`
}
type WindowsContainer_AdOrganizationalUnit struct {
	AdOrganizationalUnit string `protobuf:"bytes,3,opt,name=ad_organizational_unit,json=adOrganizationalUnit,oneof"`
}

func (*WindowsContainer_AdDomain) isWindowsContainer_Container()             {}
func (*WindowsContainer_WindowsMachine) isWindowsContainer_Container()       {}
func (*WindowsContainer_AdOrganizationalUnit) isWindowsContainer_Container() {}

func (m *WindowsContainer) GetContainer() isWindowsContainer_Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *WindowsContainer) GetAdDomain() string {
	if x, ok := m.GetContainer().(*WindowsContainer_AdDomain); ok {
		return x.AdDomain
	}
	return ""
}

func (m *WindowsContainer) GetWindowsMachine() string {
	if x, ok := m.GetContainer().(*WindowsContainer_WindowsMachine); ok {
		return x.WindowsMachine
	}
	return ""
}

func (m *WindowsContainer) GetAdOrganizationalUnit() string {
	if x, ok := m.GetContainer().(*WindowsContainer_AdOrganizationalUnit); ok {
		return x.AdOrganizationalUnit
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WindowsContainer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WindowsContainer_OneofMarshaler, _WindowsContainer_OneofUnmarshaler, _WindowsContainer_OneofSizer, []interface{}{
		(*WindowsContainer_AdDomain)(nil),
		(*WindowsContainer_WindowsMachine)(nil),
		(*WindowsContainer_AdOrganizationalUnit)(nil),
	}
}

func _WindowsContainer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WindowsContainer)
	// container
	switch x := m.Container.(type) {
	case *WindowsContainer_AdDomain:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.AdDomain)
	case *WindowsContainer_WindowsMachine:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.WindowsMachine)
	case *WindowsContainer_AdOrganizationalUnit:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.AdOrganizationalUnit)
	case nil:
	default:
		return fmt.Errorf("WindowsContainer.Container has unexpected type %T", x)
	}
	return nil
}

func _WindowsContainer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WindowsContainer)
	switch tag {
	case 1: // container.ad_domain
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Container = &WindowsContainer_AdDomain{x}
		return true, err
	case 2: // container.windows_machine
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Container = &WindowsContainer_WindowsMachine{x}
		return true, err
	case 3: // container.ad_organizational_unit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Container = &WindowsContainer_AdOrganizationalUnit{x}
		return true, err
	default:
		return false, nil
	}
}

func _WindowsContainer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WindowsContainer)
	// container
	switch x := m.Container.(type) {
	case *WindowsContainer_AdDomain:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.AdDomain)))
		n += len(x.AdDomain)
	case *WindowsContainer_WindowsMachine:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.WindowsMachine)))
		n += len(x.WindowsMachine)
	case *WindowsContainer_AdOrganizationalUnit:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.AdOrganizationalUnit)))
		n += len(x.AdOrganizationalUnit)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Descibes an Active Directory or Windows local group.
type WindowsGroup struct {
	// Name of the group. Exclude the domain name. The name alone is not
	// sufficient if this group corresponds to a Well Known group. Use the
	// |well_known_sid| field for that.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The actual Unicode Windows group name. Only specify this if the desired
	// name is different from the |name| field due to not being an RFC 1035
	// label.
	FullName string `protobuf:"bytes,2,opt,name=full_name,json=fullName" json:"full_name,omitempty"`
	// Human readable description of the group.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// Container for the group. A container must be specified for a WindowsGroup.
	Container *WindowsContainer `protobuf:"bytes,4,opt,name=container" json:"container,omitempty"`
	// Well-known security identifier. The string should be of the form S-* and
	// should correspond to a known SID as described in
	// https://support.microsoft.com/en-us/help/243330/well-known-security-identifiers-in-windows-operating-systems.
	//
	// Only specify this field if this group corresponds to a well known group.
	WellKnownSid string `protobuf:"bytes,5,opt,name=well_known_sid,json=wellKnownSid" json:"well_known_sid,omitempty"`
}

func (m *WindowsGroup) Reset()                    { *m = WindowsGroup{} }
func (m *WindowsGroup) String() string            { return proto.CompactTextString(m) }
func (*WindowsGroup) ProtoMessage()               {}
func (*WindowsGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *WindowsGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WindowsGroup) GetFullName() string {
	if m != nil {
		return m.FullName
	}
	return ""
}

func (m *WindowsGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *WindowsGroup) GetContainer() *WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *WindowsGroup) GetWellKnownSid() string {
	if m != nil {
		return m.WellKnownSid
	}
	return ""
}

// A reference to a group. The combination of |name| and |container| must match
// one of the WindowsGroup entries.
type GroupReference struct {
	// The name of the group.
	WindowsGroup string `protobuf:"bytes,1,opt,name=windows_group,json=windowsGroup" json:"windows_group,omitempty"`
	// Location. Since GroupReference messages are typically specified as a field
	// of an object that already has a container, omiting this field results in
	// the GroupReference inheriting the parent object's container. Take for
	// example, the following WindowsUser definition:
	//
	//     windows_user {
	//       name: 'joe'
	//       container: { domain: 'foo.example' }
	//       member_of: { name: 'bar' }
	//     }
	//
	// This results in the user being a member of the group 'bar' in the
	// 'foo.example' AD domain because that's the enclosing container.  Note
	// however, that inheriting in this manner isn't always correct since it is
	// possible for users to be members of groups from other containers.
	Container *WindowsContainer `protobuf:"bytes,2,opt,name=container" json:"container,omitempty"`
}

func (m *GroupReference) Reset()                    { *m = GroupReference{} }
func (m *GroupReference) String() string            { return proto.CompactTextString(m) }
func (*GroupReference) ProtoMessage()               {}
func (*GroupReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GroupReference) GetWindowsGroup() string {
	if m != nil {
		return m.WindowsGroup
	}
	return ""
}

func (m *GroupReference) GetContainer() *WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

// A reference to a user. The combination of |name| and |container| must match
// one of the WindowsUser entries.
type UserReference struct {
	// The name of the user.
	WindowsUser string `protobuf:"bytes,1,opt,name=windows_user,json=windowsUser" json:"windows_user,omitempty"`
	// Location. See GroupReference for how the container parameters are
	// determined by default.
	Container *WindowsContainer `protobuf:"bytes,2,opt,name=container" json:"container,omitempty"`
}

func (m *UserReference) Reset()                    { *m = UserReference{} }
func (m *UserReference) String() string            { return proto.CompactTextString(m) }
func (*UserReference) ProtoMessage()               {}
func (*UserReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *UserReference) GetWindowsUser() string {
	if m != nil {
		return m.WindowsUser
	}
	return ""
}

func (m *UserReference) GetContainer() *WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

// A reference to a user or a group. Provided as a convenience for cases where
// either a single user or a group can be specified.
type UserOrGroupReference struct {
	// Types that are valid to be assigned to Entity:
	//	*UserOrGroupReference_User
	//	*UserOrGroupReference_Group
	Entity isUserOrGroupReference_Entity `protobuf_oneof:"entity"`
}

func (m *UserOrGroupReference) Reset()                    { *m = UserOrGroupReference{} }
func (m *UserOrGroupReference) String() string            { return proto.CompactTextString(m) }
func (*UserOrGroupReference) ProtoMessage()               {}
func (*UserOrGroupReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type isUserOrGroupReference_Entity interface {
	isUserOrGroupReference_Entity()
}

type UserOrGroupReference_User struct {
	User *UserReference `protobuf:"bytes,1,opt,name=user,oneof"`
}
type UserOrGroupReference_Group struct {
	Group *GroupReference `protobuf:"bytes,2,opt,name=group,oneof"`
}

func (*UserOrGroupReference_User) isUserOrGroupReference_Entity()  {}
func (*UserOrGroupReference_Group) isUserOrGroupReference_Entity() {}

func (m *UserOrGroupReference) GetEntity() isUserOrGroupReference_Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *UserOrGroupReference) GetUser() *UserReference {
	if x, ok := m.GetEntity().(*UserOrGroupReference_User); ok {
		return x.User
	}
	return nil
}

func (m *UserOrGroupReference) GetGroup() *GroupReference {
	if x, ok := m.GetEntity().(*UserOrGroupReference_Group); ok {
		return x.Group
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UserOrGroupReference) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UserOrGroupReference_OneofMarshaler, _UserOrGroupReference_OneofUnmarshaler, _UserOrGroupReference_OneofSizer, []interface{}{
		(*UserOrGroupReference_User)(nil),
		(*UserOrGroupReference_Group)(nil),
	}
}

func _UserOrGroupReference_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UserOrGroupReference)
	// entity
	switch x := m.Entity.(type) {
	case *UserOrGroupReference_User:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.User); err != nil {
			return err
		}
	case *UserOrGroupReference_Group:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Group); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("UserOrGroupReference.Entity has unexpected type %T", x)
	}
	return nil
}

func _UserOrGroupReference_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UserOrGroupReference)
	switch tag {
	case 1: // entity.user
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UserReference)
		err := b.DecodeMessage(msg)
		m.Entity = &UserOrGroupReference_User{msg}
		return true, err
	case 2: // entity.group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GroupReference)
		err := b.DecodeMessage(msg)
		m.Entity = &UserOrGroupReference_Group{msg}
		return true, err
	default:
		return false, nil
	}
}

func _UserOrGroupReference_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UserOrGroupReference)
	// entity
	switch x := m.Entity.(type) {
	case *UserOrGroupReference_User:
		s := proto.Size(x.User)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UserOrGroupReference_Group:
		s := proto.Size(x.Group)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Describes a Active Directory or a Windows local user.
type WindowsUser struct {
	// Name of the user. Exclude the domain name.
	//
	// E.g.: joe
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The actual Unicode Windows user name. Only specify this if the desired
	// name is different from the |name| field due to not being an RFC 1035
	// label.
	FullName string `protobuf:"bytes,2,opt,name=full_name,json=fullName" json:"full_name,omitempty"`
	// Description.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// Container for the user. A container must be specified for a WindowsUser.
	Container *WindowsContainer `protobuf:"bytes,4,opt,name=container" json:"container,omitempty"`
	// Password. Can be left blank in which case each instantiation of the lab
	// will cause a new password to be generated.
	Password string `protobuf:"bytes,5,opt,name=password" json:"password,omitempty"`
	// List of groups that the user belongs to.
	MemberOf []*GroupReference `protobuf:"bytes,6,rep,name=member_of,json=memberOf" json:"member_of,omitempty"`
}

func (m *WindowsUser) Reset()                    { *m = WindowsUser{} }
func (m *WindowsUser) String() string            { return proto.CompactTextString(m) }
func (*WindowsUser) ProtoMessage()               {}
func (*WindowsUser) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *WindowsUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WindowsUser) GetFullName() string {
	if m != nil {
		return m.FullName
	}
	return ""
}

func (m *WindowsUser) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *WindowsUser) GetContainer() *WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *WindowsUser) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *WindowsUser) GetMemberOf() []*GroupReference {
	if m != nil {
		return m.MemberOf
	}
	return nil
}

// NetworkInterface describes a single network interface on a machine.
type NetworkInterface struct {
	// Name of Network entry describing the network that this interface is
	// attached to.
	Network string `protobuf:"bytes,1,opt,name=network" json:"network,omitempty"`
	// Fixed address, if this interface is to have one. Leave undefined if the
	// interface should obatain an address automatically.
	FixedAddress *FixedAddress `protobuf:"bytes,2,opt,name=fixed_address,json=fixedAddress" json:"fixed_address,omitempty"`
}

func (m *NetworkInterface) Reset()                    { *m = NetworkInterface{} }
func (m *NetworkInterface) String() string            { return proto.CompactTextString(m) }
func (*NetworkInterface) ProtoMessage()               {}
func (*NetworkInterface) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *NetworkInterface) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *NetworkInterface) GetFixedAddress() *FixedAddress {
	if m != nil {
		return m.FixedAddress
	}
	return nil
}

// A Windows machine.
type WindowsMachine struct {
	// Name of the machine. This name will become the hostname for the machine,
	// both absolute and domain relative (if applicable). Hence must be globally
	// unique.
	//
	// For Windows machines, it's advisable to have *short* hostnames, ideally
	// shorter than 11 characters. This allows the name to do double duty as a
	// NetBios name as well as a DNS hostname.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Container. Only |domain| and |ou| values are acceptable. Currently
	// |machine| is not a valid option. If no container is specified, the machine
	// will be brought up as a standalone workstation or server depending on the
	// installed operating system.
	//
	// This field should be empty for a machine that's referenced in a
	// ActiveDirectoryDomainController entry.
	//
	// Specifying this field results in the machine being joined to the specified
	// domain and, if necessary, placed in the specified container.
	Container *WindowsContainer `protobuf:"bytes,3,opt,name=container" json:"container,omitempty"`
	// The name of a host.MachineType entry that describes the host machine.
	MachineType string `protobuf:"bytes,4,opt,name=machine_type,json=machineType" json:"machine_type,omitempty"`
	// System locale. If left unspecified, the default is left unchanged. Use the
	// following PowerShell command to determine the list of available locales on
	// a Windows machine:
	//
	//     ``` ps1
	//     [System.Globalization.CultureInfo]::GetCultures([System.Globalization.CultureTypes]::AllCultures).name
	//     ```
	//
	// PS DSC Reference:
	// * https://github.com/PowerShell/SystemLocaleDsc
	Locale string `protobuf:"bytes,5,opt,name=locale" json:"locale,omitempty"`
	// Set the system timezone. If left unspecified, the default is left
	// unchanged. Use the following PowerShell command to determine the lsit of
	// available timezone identifiers on a Windows machine:
	//
	//     ``` ps1
	//     [System.TimeZoneInfo]::GetSystemTimeZones().Id
	//     ```
	//
	// PS DSC Reference:
	// * https://github.com/PowerShell/xTimeZone
	Timezone string `protobuf:"bytes,6,opt,name=timezone" json:"timezone,omitempty"`
	// Network interfaces. There can be more than one for multihomed machines.
	// There MUST be at least one of these.
	NetworkInterface []*NetworkInterface `protobuf:"bytes,7,rep,name=network_interface,json=networkInterface" json:"network_interface,omitempty"`
	// List of additional Windows features or roles to install. The values here
	// should be valid for the selected host machine type. You can use the
	// 'Get-WindowsFeature' PowerShell commandlet to retrieve a list of available
	// Windows features.
	//
	// E.g.: windows_feature: "Web-Server"
	//
	// Note: This method cannot be used to specify all sub-features. All
	// features that needs to be installed should be listed explicitly.
	//
	// Note: Addition of roles can cause features to be installed implicitly.
	// E.g. specifying a machine as the host for an IIS site will automatically
	// install the necessary web server roles. The |windows_feature| field should
	// be used for features that otherwise won't be installed as part of any such
	// role assignment.
	//
	// Note: Any 'package' values specified in the
	// host.machine_type.<machine-type> will be prepended to this list.
	WindowsFeature []string `protobuf:"bytes,8,rep,name=windows_feature,json=windowsFeature" json:"windows_feature,omitempty"`
	// Registry keys to set on the machine. These will be applied prior to the
	// user login.
	RegistryKey []*RegistryKey `protobuf:"bytes,9,rep,name=registry_key,json=registryKey" json:"registry_key,omitempty"`
	// A configuration file. Specify this if you've run Windows Server Manager
	// and produced a configration file already.
	ConfigurationFile *common1.FileReference `protobuf:"bytes,10,opt,name=configuration_file,json=configurationFile" json:"configuration_file,omitempty"`
}

func (m *WindowsMachine) Reset()                    { *m = WindowsMachine{} }
func (m *WindowsMachine) String() string            { return proto.CompactTextString(m) }
func (*WindowsMachine) ProtoMessage()               {}
func (*WindowsMachine) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *WindowsMachine) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WindowsMachine) GetContainer() *WindowsContainer {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *WindowsMachine) GetMachineType() string {
	if m != nil {
		return m.MachineType
	}
	return ""
}

func (m *WindowsMachine) GetLocale() string {
	if m != nil {
		return m.Locale
	}
	return ""
}

func (m *WindowsMachine) GetTimezone() string {
	if m != nil {
		return m.Timezone
	}
	return ""
}

func (m *WindowsMachine) GetNetworkInterface() []*NetworkInterface {
	if m != nil {
		return m.NetworkInterface
	}
	return nil
}

func (m *WindowsMachine) GetWindowsFeature() []string {
	if m != nil {
		return m.WindowsFeature
	}
	return nil
}

func (m *WindowsMachine) GetRegistryKey() []*RegistryKey {
	if m != nil {
		return m.RegistryKey
	}
	return nil
}

func (m *WindowsMachine) GetConfigurationFile() *common1.FileReference {
	if m != nil {
		return m.ConfigurationFile
	}
	return nil
}

func init() {
	proto.RegisterType((*ActiveDirectoryDomain)(nil), "asset.ActiveDirectoryDomain")
	proto.RegisterType((*ActiveDirectoryDomainController)(nil), "asset.ActiveDirectoryDomainController")
	proto.RegisterType((*ActiveDirectoryOrganizationalUnit)(nil), "asset.ActiveDirectoryOrganizationalUnit")
	proto.RegisterType((*ActiveDirectoryGroupPolicy)(nil), "asset.ActiveDirectoryGroupPolicy")
	proto.RegisterType((*ActiveDirectoryGroupPolicyLink)(nil), "asset.ActiveDirectoryGroupPolicyLink")
	proto.RegisterType((*ActiveDirectoryRegistryPolicy)(nil), "asset.ActiveDirectoryRegistryPolicy")
	proto.RegisterType((*ActiveDirectoryRegistryPrefPolicy)(nil), "asset.ActiveDirectoryRegistryPrefPolicy")
	proto.RegisterType((*RegistryKey)(nil), "asset.RegistryKey")
	proto.RegisterType((*RegistryValue)(nil), "asset.RegistryValue")
	proto.RegisterType((*WindowsContainer)(nil), "asset.WindowsContainer")
	proto.RegisterType((*WindowsGroup)(nil), "asset.WindowsGroup")
	proto.RegisterType((*GroupReference)(nil), "asset.GroupReference")
	proto.RegisterType((*UserReference)(nil), "asset.UserReference")
	proto.RegisterType((*UserOrGroupReference)(nil), "asset.UserOrGroupReference")
	proto.RegisterType((*WindowsUser)(nil), "asset.WindowsUser")
	proto.RegisterType((*NetworkInterface)(nil), "asset.NetworkInterface")
	proto.RegisterType((*WindowsMachine)(nil), "asset.WindowsMachine")
	proto.RegisterEnum("asset.RegistryValueType", RegistryValueType_name, RegistryValueType_value)
	proto.RegisterEnum("asset.ActiveDirectoryDomain_Mode", ActiveDirectoryDomain_Mode_name, ActiveDirectoryDomain_Mode_value)
	proto.RegisterEnum("asset.ActiveDirectoryDomain_Type", ActiveDirectoryDomain_Type_name, ActiveDirectoryDomain_Type_value)
	proto.RegisterEnum("asset.ActiveDirectoryRegistryPrefPolicy_Action", ActiveDirectoryRegistryPrefPolicy_Action_name, ActiveDirectoryRegistryPrefPolicy_Action_value)
}

func init() { proto.RegisterFile("schema/asset/active_directory.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1685 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4d, 0x6f, 0x1b, 0xc7,
	0x19, 0xe6, 0x97, 0xa8, 0xe5, 0x4b, 0x52, 0x5a, 0x8d, 0xa4, 0x78, 0x4b, 0xa5, 0xa9, 0xbd, 0x0d,
	0x50, 0xd7, 0x68, 0xa4, 0x98, 0xae, 0x0d, 0xd7, 0x41, 0x0a, 0x88, 0x22, 0x65, 0x09, 0x91, 0x25,
	0x75, 0x22, 0x55, 0x6d, 0x2e, 0x8b, 0xd1, 0xee, 0x90, 0x5a, 0x78, 0x39, 0x43, 0xcc, 0x2e, 0xad,
	0x32, 0xb9, 0xa9, 0x87, 0xde, 0x7b, 0xeb, 0x1f, 0xe8, 0x3f, 0xd0, 0xa5, 0x97, 0xde, 0xfa, 0x07,
	0x72, 0xea, 0xaf, 0xe8, 0xb9, 0xb7, 0x62, 0x3e, 0x96, 0xe4, 0x92, 0x8c, 0x20, 0x1b, 0x2d, 0xd0,
	0xdb, 0xce, 0xfb, 0x31, 0xf3, 0xcc, 0xfb, 0xf1, 0xbc, 0x43, 0xc2, 0x4f, 0x63, 0xff, 0x8a, 0xf6,
	0xc9, 0x0e, 0x89, 0x63, 0x9a, 0xec, 0x10, 0x3f, 0x09, 0xdf, 0x51, 0x2f, 0x08, 0x05, 0xf5, 0x13,
	0x2e, 0x46, 0xdb, 0x03, 0xc1, 0x13, 0x8e, 0x96, 0x94, 0xb6, 0xb1, 0x65, 0x6c, 0x7d, 0xde, 0xef,
	0x73, 0xb6, 0xd3, 0x0d, 0x23, 0x2a, 0x68, 0x57, 0xdb, 0x34, 0x1a, 0x99, 0x8d, 0x18, 0x4d, 0xae,
	0xb9, 0x78, 0x6b, 0x74, 0x33, 0x8e, 0x7c, 0x90, 0x84, 0x9c, 0xc5, 0x5a, 0xe9, 0x7e, 0x5f, 0x84,
	0xcd, 0x5d, 0x75, 0x6e, 0x3b, 0x3d, 0xb6, 0xcd, 0xfb, 0x24, 0x64, 0xa8, 0x01, 0x25, 0x46, 0xfa,
	0xd4, 0xc9, 0x3f, 0xcc, 0x3f, 0xae, 0xb4, 0xca, 0x37, 0xb7, 0x4e, 0xc1, 0x2a, 0x61, 0x25, 0x43,
	0x2f, 0xa1, 0x3a, 0x20, 0x82, 0xb2, 0xc4, 0x53, 0x26, 0x05, 0x65, 0xf2, 0xe0, 0xe6, 0xd6, 0x59,
	0x47, 0xab, 0x0a, 0xc2, 0x36, 0x09, 0xbc, 0x40, 0xed, 0xe3, 0xe4, 0x31, 0x68, 0xdb, 0x63, 0xe9,
	0xd9, 0x82, 0xaa, 0x96, 0x7b, 0x7d, 0x1e, 0x50, 0xa7, 0xf8, 0x30, 0xff, 0x78, 0xa5, 0xf9, 0x68,
	0x5b, 0x3b, 0x2d, 0x04, 0xb2, 0xfd, 0x86, 0x07, 0x14, 0x83, 0xf6, 0x92, 0xdf, 0xe8, 0x11, 0xd4,
	0x18, 0x4d, 0x2e, 0x43, 0x1e, 0xeb, 0xe3, 0x4b, 0xf2, 0x78, 0x5c, 0x35, 0x32, 0x75, 0xcc, 0x73,
	0x28, 0x25, 0xa3, 0x01, 0x75, 0x96, 0xee, 0xb1, 0xff, 0xd9, 0x68, 0x40, 0xb1, 0x32, 0x97, 0xe8,
	0xba, 0x5c, 0xd0, 0x38, 0xd1, 0xe8, 0xca, 0xf7, 0x46, 0xa7, 0xbd, 0xe4, 0xb7, 0x4b, 0xa1, 0xa4,
	0x50, 0x56, 0x61, 0xb9, 0xdd, 0xd9, 0xdf, 0x3d, 0x3f, 0x3a, 0xb3, 0x73, 0x72, 0x71, 0x11, 0xb2,
	0xe6, 0xe7, 0x9f, 0x3f, 0xb3, 0x0b, 0x93, 0xc5, 0x4b, 0xbb, 0x88, 0xea, 0x50, 0x31, 0x0b, 0xdc,
	0xb4, 0x4b, 0x63, 0xdd, 0xd3, 0xa6, 0xbd, 0x34, 0xd6, 0x3d, 0x6d, 0xe2, 0xa6, 0x5d, 0x9e, 0xe8,
	0x5e, 0xd8, 0xcb, 0xee, 0x16, 0x94, 0x24, 0x70, 0x54, 0x81, 0xa5, 0xbd, 0x83, 0xc3, 0xa3, 0xb6,
	0x9d, 0x43, 0x16, 0x94, 0xce, 0x70, 0xa7, 0x63, 0xe7, 0xdd, 0x7f, 0x16, 0xe0, 0x27, 0x0b, 0xe1,
	0xee, 0x71, 0x96, 0x08, 0x1e, 0x45, 0x54, 0xa0, 0x26, 0x54, 0xa6, 0x92, 0xa4, 0x32, 0xb8, 0x79,
	0x73, 0xeb, 0xac, 0xcd, 0x65, 0x10, 0x5b, 0x24, 0x30, 0x35, 0xd1, 0x86, 0xd5, 0xeb, 0x90, 0x05,
	0xfc, 0x3a, 0xf6, 0xfa, 0xc4, 0xbf, 0x0a, 0x59, 0x9a, 0xfb, 0xad, 0x9b, 0x5b, 0xe7, 0x01, 0xda,
	0xd4, 0x9e, 0x33, 0x26, 0x78, 0xc5, 0x08, 0xde, 0xe8, 0x35, 0x7a, 0x04, 0xd5, 0x90, 0xc5, 0x09,
	0x89, 0x22, 0x2f, 0x60, 0xb1, 0xaa, 0x01, 0xeb, 0x20, 0x87, 0xc1, 0x08, 0xdb, 0x2c, 0x46, 0x3f,
	0x87, 0x35, 0xc6, 0xa5, 0xd6, 0xe3, 0xcc, 0x33, 0xe5, 0xac, 0xf2, 0x6c, 0xe1, 0x15, 0xc6, 0xdb,
	0x2c, 0x3e, 0x61, 0xc7, 0x5a, 0x8a, 0x9e, 0x28, 0xd3, 0x5e, 0xc4, 0x2f, 0x49, 0xe4, 0xf9, 0x24,
	0x21, 0x11, 0xef, 0xa9, 0xbc, 0x5b, 0x78, 0x95, 0xf1, 0xd7, 0x4a, 0xbe, 0xa7, 0xc5, 0xa8, 0x09,
	0x9b, 0xbe, 0xa0, 0x24, 0xa1, 0x6a, 0xeb, 0x80, 0x46, 0xb4, 0x47, 0x64, 0x37, 0xa8, 0x4c, 0x5b,
	0x78, 0x5d, 0x2b, 0xdb, 0x2c, 0x6e, 0x8f, 0x55, 0xad, 0x15, 0xa8, 0xe9, 0x96, 0x21, 0x0a, 0xae,
	0xfb, 0x97, 0x12, 0x3c, 0x9a, 0x89, 0xed, 0x89, 0xe8, 0x11, 0x16, 0x7e, 0x4b, 0xb4, 0xd5, 0x39,
	0x0b, 0x13, 0x84, 0xa6, 0xbb, 0xc7, 0x74, 0xcd, 0x16, 0x54, 0xba, 0xc3, 0x28, 0x9a, 0xea, 0x19,
	0x6c, 0x49, 0x81, 0xaa, 0xd8, 0x2f, 0xa1, 0xe2, 0x73, 0x96, 0x90, 0x90, 0x51, 0xa1, 0x42, 0x52,
	0x6d, 0x3e, 0x30, 0x85, 0x77, 0xa1, 0xc3, 0xb7, 0x97, 0xaa, 0x4d, 0x33, 0xe6, 0xf1, 0xc4, 0x03,
	0x3d, 0x83, 0x72, 0x4c, 0xc5, 0x3b, 0x2a, 0x74, 0x37, 0xdc, 0x9d, 0x10, 0x63, 0x8a, 0xbe, 0x04,
	0xeb, 0x92, 0xc4, 0x34, 0xf0, 0x38, 0x53, 0x11, 0xab, 0xb4, 0xdc, 0x9b, 0x5b, 0xe7, 0x13, 0xf4,
	0xf1, 0xb8, 0x02, 0x78, 0xe6, 0x66, 0xde, 0x90, 0x85, 0x09, 0x5e, 0x56, 0x3e, 0x27, 0x4c, 0xf6,
	0x61, 0x10, 0xc6, 0x83, 0x88, 0x8c, 0xf4, 0x95, 0xca, 0xba, 0x0f, 0x8d, 0x4c, 0xdd, 0xea, 0x21,
	0x54, 0x03, 0x1a, 0xfb, 0x22, 0x54, 0x11, 0x74, 0x96, 0x8d, 0xc5, 0x44, 0x84, 0x5e, 0x01, 0xf4,
	0x09, 0x23, 0x3d, 0x1a, 0x78, 0x97, 0x23, 0xc7, 0x52, 0x17, 0xdf, 0x32, 0x17, 0x3f, 0x8f, 0xa9,
	0x38, 0x11, 0xaf, 0x05, 0x1f, 0x0e, 0x30, 0xed, 0x52, 0x41, 0x99, 0x4f, 0x71, 0xc5, 0x98, 0xb7,
	0x46, 0x08, 0x83, 0x35, 0x10, 0x7c, 0x40, 0x45, 0x32, 0x72, 0x2a, 0x0f, 0x8b, 0x8f, 0xab, 0xcd,
	0x17, 0x8b, 0x7b, 0x75, 0x3e, 0x41, 0xdb, 0xa7, 0xc6, 0xb1, 0xc3, 0x12, 0x31, 0xc2, 0xe3, 0x7d,
	0x1a, 0x5f, 0x40, 0x3d, 0xa3, 0x42, 0x36, 0x14, 0xdf, 0xd2, 0x91, 0x49, 0xa4, 0xfc, 0x44, 0x1b,
	0xb0, 0xf4, 0x8e, 0x44, 0xc3, 0x34, 0x87, 0x7a, 0xf1, 0xaa, 0xf0, 0x32, 0xef, 0x7e, 0x9f, 0x87,
	0xc6, 0xcc, 0xd1, 0x0a, 0xfd, 0x29, 0x8f, 0x42, 0x7f, 0xf4, 0xfe, 0x45, 0x91, 0xe9, 0xd1, 0xe2,
	0xfd, 0x7a, 0xd4, 0x81, 0x65, 0xc9, 0xf4, 0x94, 0x25, 0x86, 0x18, 0xd3, 0x25, 0x7a, 0x31, 0x97,
	0xee, 0x4c, 0x95, 0x90, 0xc0, 0xeb, 0x49, 0xb0, 0xde, 0x40, 0xa1, 0x1d, 0xe7, 0xd9, 0xfd, 0x73,
	0x01, 0x3e, 0xf9, 0xe1, 0x5b, 0x1d, 0x85, 0xec, 0xed, 0xc2, 0x9b, 0xed, 0xc1, 0xea, 0xcc, 0x96,
	0x8b, 0xc8, 0x62, 0xf6, 0xd4, 0x3a, 0x09, 0xa6, 0x43, 0xf6, 0x3c, 0xdb, 0x16, 0xc5, 0x3b, 0xda,
	0x62, 0xba, 0x1d, 0x3e, 0x06, 0x8b, 0xb2, 0x2e, 0x17, 0x3e, 0x0d, 0x34, 0x6d, 0x1c, 0xe4, 0xf0,
	0x58, 0x82, 0x1a, 0xb0, 0x4c, 0x19, 0xb9, 0x8c, 0x68, 0xa0, 0x89, 0xe2, 0x20, 0x8f, 0x53, 0x41,
	0x0b, 0x81, 0x3d, 0x6e, 0x77, 0xe3, 0x30, 0x23, 0x53, 0x76, 0xee, 0xdf, 0xf2, 0xf0, 0xe3, 0x99,
	0xa0, 0x60, 0xda, 0x0b, 0xe3, 0x44, 0x8c, 0xee, 0xc8, 0xf6, 0x7f, 0x25, 0x26, 0x0d, 0xb0, 0x48,
	0x10, 0x84, 0xf2, 0x6c, 0x4d, 0x9e, 0x78, 0xbc, 0x46, 0x9f, 0xea, 0x6a, 0x2d, 0xa9, 0x48, 0x21,
	0x13, 0xa9, 0x14, 0xd8, 0x57, 0x74, 0xa4, 0x2a, 0xd8, 0xfd, 0x6b, 0x61, 0x8e, 0xc3, 0xc6, 0xe0,
	0x05, 0xed, 0xfe, 0xaf, 0x2f, 0xf0, 0x1a, 0xca, 0xf2, 0xad, 0xc3, 0x99, 0x99, 0xff, 0x3b, 0x8b,
	0xbb, 0x76, 0x1e, 0x92, 0xb2, 0xe0, 0x0c, 0x1b, 0xf7, 0x7b, 0xde, 0xf6, 0x57, 0x50, 0xd6, 0x7e,
	0x08, 0xa0, 0xbc, 0x87, 0x3b, 0xbb, 0x67, 0x1d, 0x3d, 0x92, 0x71, 0xe7, 0xf4, 0x68, 0x77, 0xaf,
	0x63, 0xe7, 0xa5, 0xe2, 0xfc, 0xb4, 0x2d, 0x15, 0x05, 0xf9, 0xdd, 0xee, 0x1c, 0x75, 0xce, 0x3a,
	0x76, 0xd1, 0x3d, 0x87, 0xea, 0xd4, 0x76, 0xf2, 0x4d, 0x34, 0x20, 0xc9, 0x55, 0xe6, 0x4d, 0x94,
	0xc7, 0x4a, 0x86, 0x9e, 0x4c, 0x58, 0x41, 0xa2, 0xd9, 0x98, 0x41, 0xf3, 0x5b, 0xa9, 0x33, 0x5c,
	0xe1, 0xf6, 0xa0, 0x9e, 0x91, 0x2f, 0x0c, 0xf5, 0x2f, 0xcc, 0x1b, 0xa6, 0xa0, 0x62, 0xe4, 0x2c,
	0xda, 0x6f, 0xea, 0xe9, 0x32, 0x26, 0x25, 0xd9, 0x24, 0x29, 0x29, 0xb9, 0xff, 0xce, 0x83, 0x3d,
	0xdb, 0x27, 0xe8, 0x97, 0xf7, 0x9d, 0xfc, 0xb2, 0x69, 0xc6, 0xbc, 0xb2, 0xff, 0x21, 0xb3, 0xff,
	0x20, 0x37, 0x37, 0xfd, 0xbf, 0x81, 0x8f, 0x16, 0x0f, 0x16, 0x43, 0x70, 0xf7, 0x18, 0x41, 0x07,
	0x39, 0xbc, 0x41, 0x82, 0x79, 0x52, 0x6f, 0x55, 0xa7, 0xd8, 0xc2, 0xfd, 0x47, 0x1e, 0x6a, 0xe6,
	0xee, 0xaa, 0xf8, 0xde, 0x9f, 0x7e, 0x67, 0xa6, 0x57, 0x71, 0x7e, 0x7a, 0x65, 0xa6, 0x76, 0xe9,
	0xbd, 0xa7, 0xf6, 0xa7, 0xb0, 0x72, 0x4d, 0xa3, 0xc8, 0x7b, 0xcb, 0xf8, 0x35, 0xf3, 0xe2, 0x50,
	0xf3, 0x51, 0x05, 0xd7, 0xa4, 0xf4, 0x2b, 0x29, 0xfc, 0x3a, 0x0c, 0xdc, 0x3f, 0xe5, 0x61, 0x25,
	0x3b, 0x04, 0xd1, 0xaf, 0xa1, 0x9e, 0x46, 0x5a, 0x35, 0x9a, 0x49, 0xe3, 0x8f, 0x6e, 0x6e, 0x9d,
	0x4d, 0xb4, 0x9e, 0x4d, 0x85, 0x32, 0xc0, 0xb5, 0xeb, 0xe9, 0x50, 0x64, 0x68, 0xb5, 0x70, 0x27,
	0xee, 0x29, 0xbc, 0xee, 0x1f, 0xf3, 0x50, 0x97, 0x43, 0x79, 0x02, 0xe4, 0x0b, 0x48, 0x37, 0xf6,
	0x86, 0x31, 0x15, 0x06, 0x87, 0x73, 0x73, 0xeb, 0x6c, 0x20, 0x94, 0xc5, 0x21, 0xf5, 0xb8, 0x6a,
	0x56, 0x72, 0x97, 0x0f, 0x45, 0xf1, 0x1d, 0x6c, 0x2c, 0x7a, 0x19, 0xa0, 0x27, 0x50, 0x1a, 0x63,
	0x98, 0x34, 0x60, 0x06, 0xef, 0x41, 0x0e, 0x2b, 0x1b, 0xf4, 0x19, 0x2c, 0xe9, 0xc0, 0xe9, 0x63,
	0x37, 0x8d, 0x71, 0x76, 0xc7, 0x83, 0x1c, 0xd6, 0x56, 0x2d, 0x0b, 0xca, 0x94, 0x25, 0x61, 0x32,
	0x72, 0xff, 0x95, 0x87, 0xea, 0xc5, 0xd4, 0x1d, 0xfe, 0xff, 0x8a, 0xaa, 0x01, 0xd6, 0x80, 0xc4,
	0xf1, 0x35, 0x17, 0x69, 0x39, 0x8d, 0xd7, 0xf2, 0x41, 0xd1, 0xa7, 0xfd, 0x4b, 0x2a, 0x3c, 0xde,
	0x75, 0xca, 0x8a, 0xa8, 0x16, 0x5f, 0x1d, 0x5b, 0xda, 0xee, 0xa4, 0xeb, 0x7e, 0x07, 0xb6, 0x79,
	0x6b, 0x1f, 0xb2, 0x84, 0x8a, 0x2e, 0xf1, 0x29, 0xfa, 0x0c, 0x96, 0xd3, 0x57, 0xb9, 0xce, 0xf8,
	0xfa, 0xcd, 0xad, 0xb3, 0x8a, 0xea, 0x7a, 0x2b, 0xa3, 0xc2, 0xa9, 0x0d, 0x7a, 0x09, 0xf5, 0x6e,
	0xf8, 0x07, 0x1a, 0x78, 0x24, 0x08, 0x04, 0x8d, 0x63, 0x13, 0xf5, 0x75, 0x73, 0xf4, 0xbe, 0xd4,
	0xed, 0x6a, 0x15, 0xae, 0x75, 0xa7, 0x56, 0xee, 0xdf, 0x8b, 0xb0, 0x72, 0x91, 0x25, 0x90, 0x45,
	0x11, 0x7f, 0x7e, 0xff, 0xd7, 0xf3, 0x74, 0xa8, 0x5e, 0x41, 0xcd, 0x10, 0x95, 0xa7, 0xa8, 0xb6,
	0x34, 0xf5, 0x43, 0x76, 0xed, 0x8a, 0xc7, 0xc9, 0xf6, 0xb4, 0x1a, 0x57, 0xcd, 0x4a, 0xfd, 0xf0,
	0xfa, 0x08, 0xca, 0x11, 0xf7, 0x49, 0x44, 0x4d, 0x90, 0xcd, 0x4a, 0x86, 0x3f, 0x09, 0xfb, 0xf4,
	0x5b, 0xce, 0xd2, 0x17, 0xf1, 0x78, 0x8d, 0x8e, 0x60, 0xcd, 0x84, 0xc4, 0x0b, 0xd3, 0x58, 0x3a,
	0xcb, 0x99, 0x57, 0xcd, 0x6c, 0xa8, 0xc7, 0x19, 0xb6, 0xd9, 0x6c, 0x12, 0x7e, 0x36, 0x61, 0xe4,
	0x2e, 0x25, 0xc9, 0x50, 0x50, 0xc7, 0x52, 0xe4, 0x9f, 0x52, 0xee, 0xbe, 0x96, 0xa2, 0xe7, 0x50,
	0x13, 0x66, 0x6c, 0x78, 0x72, 0x5e, 0x56, 0x7e, 0x70, 0x5e, 0x56, 0xc5, 0xd4, 0xb4, 0x6b, 0x03,
	0xf2, 0x39, 0xeb, 0x86, 0xbd, 0xa1, 0x50, 0x24, 0xeb, 0x75, 0xc3, 0x88, 0x3a, 0x60, 0x1a, 0x46,
	0xff, 0x9d, 0xb0, 0xbd, 0x1f, 0x46, 0x74, 0x52, 0x35, 0x6b, 0x19, 0x07, 0xa9, 0x7b, 0xd2, 0x85,
	0xb5, 0xb9, 0x99, 0x25, 0x67, 0xec, 0xd7, 0x67, 0xf8, 0xf0, 0xf8, 0xb5, 0x9d, 0x43, 0x6b, 0x50,
	0xef, 0xfc, 0xee, 0x74, 0xf7, 0xb8, 0xed, 0x19, 0x91, 0x1a, 0xc7, 0xad, 0xc3, 0xe3, 0x5d, 0xfc,
	0x7b, 0xbb, 0x20, 0x7f, 0xe0, 0xb6, 0x2f, 0x4e, 0x70, 0xdb, 0x2e, 0x22, 0x1b, 0x6a, 0x6f, 0xce,
	0x8f, 0xce, 0x0e, 0x53, 0xc3, 0x92, 0x54, 0xfe, 0x46, 0x29, 0x97, 0x5a, 0xcf, 0xbe, 0x79, 0xea,
	0x5f, 0x09, 0xde, 0x0f, 0x87, 0xfd, 0xed, 0x1e, 0xe7, 0xbd, 0x88, 0xc6, 0x7c, 0x28, 0x7c, 0x2a,
	0x81, 0xee, 0x50, 0x19, 0xb4, 0x81, 0x08, 0x63, 0xba, 0xe3, 0xd3, 0x68, 0xa7, 0xc7, 0xf5, 0x3f,
	0x25, 0x97, 0x65, 0xf5, 0x2f, 0xc8, 0xb3, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x89, 0xe8, 0x6c,
	0x4f, 0x89, 0x11, 0x00, 0x00,
}
