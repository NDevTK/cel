// Code generated by protoc-gen-go.
// source: schema/asset/iis.proto
// DO NOT EDIT!

package asset

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// An IIS server.
//
// The following Windows features will be automatically installed for all IIS servers.
//   *  Web-Common-HTTP
//   *  Web-Security
type Server struct {
	// Name of server instance.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Name of host machine. Should refer to a |WindowsMachine| entry.
	// Container information for the IIS instance will be inherited from the
	// WindowsMachine entry.
	Host string `protobuf:"bytes,2,opt,name=host" json:"host,omitempty"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *Server) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Server) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

// Bindings for a website onto a webserver.
type Bindings struct {
	// Hostname. Can be empty to bind to all hostnames.
	Hostname string `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	// Protocol. Must be either HTTP or HTTPS. If using HTTPS, the SSL
	// information is also required.
	Protocol Protocol `protobuf:"varint,2,opt,name=protocol,enum=asset.Protocol" json:"protocol,omitempty"`
	// Port to use. Leave empty to use the default port based on protocol.
	Port uint32 `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	// Name of a Certificate. This certificate should include a private key. See
	// the definition in cert.proto.
	Certificate string `protobuf:"bytes,4,opt,name=certificate" json:"certificate,omitempty"`
	// Whether or not to use SNI. Only applicable when |protocol| is HTTPS. If
	// this value is false, then only one HTTPS site can be bound to a single
	// server.
	UseSni bool `protobuf:"varint,5,opt,name=use_sni,json=useSni" json:"use_sni,omitempty"`
}

func (m *Bindings) Reset()                    { *m = Bindings{} }
func (m *Bindings) String() string            { return proto.CompactTextString(m) }
func (*Bindings) ProtoMessage()               {}
func (*Bindings) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *Bindings) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Bindings) GetProtocol() Protocol {
	if m != nil {
		return m.Protocol
	}
	return Protocol_UNKNOWN
}

func (m *Bindings) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Bindings) GetCertificate() string {
	if m != nil {
		return m.Certificate
	}
	return ""
}

func (m *Bindings) GetUseSni() bool {
	if m != nil {
		return m.UseSni
	}
	return false
}

// A single web site.
type Site struct {
	// Name of site.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Name of server. Should refer to a |Server| entry. A single server can host
	// multiple sites as long as those sites use distinct binding information.
	Server string `protobuf:"bytes,2,opt,name=server" json:"server,omitempty"`
	// Bindings. These are bindings. Specify bindings here.
	Bindings *Bindings `protobuf:"bytes,3,opt,name=bindings" json:"bindings,omitempty"`
	// Relative path to directory containing the files that will be hosted on
	// this site. The entire subtree will be copied over to the target host.
	//
	// While it is legal, avoid nesting sites and applications within a single
	// directory tree.
	Contents *FileReference `protobuf:"bytes,4,opt,name=contents" json:"contents,omitempty"`
}

func (m *Site) Reset()                    { *m = Site{} }
func (m *Site) String() string            { return proto.CompactTextString(m) }
func (*Site) ProtoMessage()               {}
func (*Site) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

func (m *Site) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Site) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *Site) GetBindings() *Bindings {
	if m != nil {
		return m.Bindings
	}
	return nil
}

func (m *Site) GetContents() *FileReference {
	if m != nil {
		return m.Contents
	}
	return nil
}

type Application struct {
	// Name of application.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Name of the iis.Site that's hosting this application.
	Site string `protobuf:"bytes,2,opt,name=site" json:"site,omitempty"`
	// Relative path to directory containing the files that will be hosted on
	// this application. The entire subtree will be copied over to the target
	// host.
	//
	// While it is legal, avoid nesting sites and applications within a single
	// directory tree.
	Contents *FileReference `protobuf:"bytes,3,opt,name=contents" json:"contents,omitempty"`
}

func (m *Application) Reset()                    { *m = Application{} }
func (m *Application) String() string            { return proto.CompactTextString(m) }
func (*Application) ProtoMessage()               {}
func (*Application) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

func (m *Application) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Application) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *Application) GetContents() *FileReference {
	if m != nil {
		return m.Contents
	}
	return nil
}

func init() {
	proto.RegisterType((*Server)(nil), "asset.Server")
	proto.RegisterType((*Bindings)(nil), "asset.Bindings")
	proto.RegisterType((*Site)(nil), "asset.Site")
	proto.RegisterType((*Application)(nil), "asset.Application")
}

func init() { proto.RegisterFile("schema/asset/iis.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 346 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0xc1, 0x4e, 0xeb, 0x30,
	0x10, 0x54, 0x5e, 0xdb, 0xbc, 0x3c, 0x47, 0x0f, 0x24, 0x0b, 0x95, 0x90, 0x53, 0x94, 0x53, 0x25,
	0xa4, 0xa4, 0xb4, 0x5f, 0x40, 0x0f, 0x9c, 0x51, 0x7a, 0xe3, 0x82, 0x52, 0xb3, 0x4d, 0x2d, 0x12,
	0x6f, 0xe4, 0x75, 0xe0, 0x3b, 0xf8, 0x05, 0xbe, 0x14, 0xd9, 0x49, 0xa3, 0x56, 0x02, 0x89, 0xdb,
	0x78, 0x76, 0xe2, 0x99, 0xd9, 0x98, 0xcd, 0x49, 0x1c, 0xa0, 0x29, 0xf3, 0x92, 0x08, 0x4c, 0x2e,
	0x25, 0x65, 0xad, 0x46, 0x83, 0x7c, 0xe6, 0x88, 0xf8, 0xe6, 0x6c, 0x2c, 0xb0, 0x69, 0x50, 0xf5,
	0x8a, 0x38, 0x3e, 0x1b, 0x29, 0x30, 0xef, 0xa8, 0x5f, 0xfb, 0x59, 0xba, 0x64, 0xfe, 0x16, 0xf4,
	0x1b, 0x68, 0xce, 0xd9, 0x54, 0x95, 0x0d, 0x44, 0x5e, 0xe2, 0x2d, 0xfe, 0x15, 0x0e, 0x5b, 0xee,
	0x80, 0x64, 0xa2, 0x3f, 0x3d, 0x67, 0x71, 0xfa, 0xe9, 0xb1, 0x60, 0x23, 0xd5, 0x8b, 0x54, 0x15,
	0xf1, 0x98, 0x05, 0x96, 0x3c, 0xf9, 0x70, 0x3c, 0xf3, 0x5b, 0x16, 0x38, 0x0f, 0x81, 0xb5, 0xbb,
	0xe0, 0x62, 0x75, 0x99, 0xb9, 0x08, 0xd9, 0xe3, 0x40, 0x17, 0xa3, 0xc0, 0x3a, 0xb5, 0xa8, 0x4d,
	0x34, 0x49, 0xbc, 0xc5, 0xff, 0xc2, 0x61, 0x9e, 0xb0, 0x50, 0x80, 0x36, 0x72, 0x2f, 0x45, 0x69,
	0x20, 0x9a, 0xba, 0xfb, 0x4f, 0x29, 0x7e, 0xcd, 0xfe, 0x76, 0x04, 0xcf, 0xa4, 0x64, 0x34, 0x4b,
	0xbc, 0x45, 0x50, 0xf8, 0x1d, 0xc1, 0x56, 0xc9, 0xf4, 0xc3, 0x63, 0xd3, 0xad, 0x34, 0xf0, 0x6d,
	0xab, 0x39, 0xf3, 0xc9, 0x75, 0x1e, 0x7a, 0x0d, 0x27, 0x1b, 0x78, 0x37, 0x14, 0x73, 0x39, 0xc2,
	0x31, 0xf0, 0xb1, 0x6f, 0x31, 0x0a, 0xf8, 0x92, 0x05, 0x02, 0x95, 0x01, 0x65, 0xc8, 0x25, 0x0b,
	0x57, 0x57, 0x83, 0xf8, 0x41, 0xd6, 0x50, 0xc0, 0x1e, 0x34, 0x28, 0x01, 0xc5, 0xa8, 0x4a, 0x2b,
	0x16, 0xde, 0xb7, 0x6d, 0x6d, 0x93, 0x4b, 0x54, 0x3f, 0xed, 0x9b, 0xa4, 0x81, 0xe3, 0xbe, 0x2d,
	0x3e, 0x33, 0x9a, 0xfc, 0xc6, 0x68, 0xb3, 0x7e, 0xba, 0x13, 0x07, 0x8d, 0x8d, 0xec, 0x9a, 0xac,
	0x42, 0xac, 0x6a, 0x20, 0xec, 0xb4, 0x80, 0x4c, 0x60, 0x93, 0x83, 0x32, 0xa0, 0x5b, 0x2d, 0x09,
	0x72, 0x01, 0x75, 0x5e, 0x61, 0xff, 0x2c, 0x76, 0xbe, 0xfb, 0x15, 0xeb, 0xaf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xf4, 0xf3, 0x35, 0x61, 0x67, 0x02, 0x00, 0x00,
}
