// Code generated by protoc-gen-go.
// source: config/config.proto
// DO NOT EDIT!

/*
Package config is a generated protocol buffer package.

It is generated from these files:
	config/config.proto

It has these top-level messages:
	Network
	FirewallRule
	SourceImage
	ServiceAccount
	InstanceServiceAccount
	Key
	InstanceCreateOptions
	NetworkInterface
	Instance
	InstanceType
	WindowsDomainAccount
	WindowsDomain
	EncryptedData
	ExternalIP
	HostEnvironment
	Assets
*/
package config

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// See on_host_maintenance.
type InstanceCreateOptions_MaintenanceOption int32

const (
	// Attempt to migrate the VM during on-host maintenance. (Default)
	InstanceCreateOptions_MIGRATE InstanceCreateOptions_MaintenanceOption = 0
	// Terminate the VM. If |automatic_restart| is true, then the VM will be
	// restarted automatically when safe to do so.
	InstanceCreateOptions_TERMINATE InstanceCreateOptions_MaintenanceOption = 1
)

var InstanceCreateOptions_MaintenanceOption_name = map[int32]string{
	0: "MIGRATE",
	1: "TERMINATE",
}
var InstanceCreateOptions_MaintenanceOption_value = map[string]int32{
	"MIGRATE":   0,
	"TERMINATE": 1,
}

func (x InstanceCreateOptions_MaintenanceOption) String() string {
	return proto.EnumName(InstanceCreateOptions_MaintenanceOption_name, int32(x))
}
func (InstanceCreateOptions_MaintenanceOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0}
}

// The user's role:
type WindowsDomainAccount_Role int32

const (
	// A minion account is what's used for running tests. There can be many
	// differnet types of minion accounts for dealing with things like per-user
	// policies etc. (Default)
	WindowsDomainAccount_MINION WindowsDomainAccount_Role = 0
	// There should be at least one account that fulfils the ADMIN role. Such an
	// account is used for setting up domain joins and other administrative
	// tasks internally.
	WindowsDomainAccount_ADMIN WindowsDomainAccount_Role = 1
	// The Windows safe mode administrator account for the domain. There should
	// be at least one of these.
	WindowsDomainAccount_SAFE_MODE_ADMIN WindowsDomainAccount_Role = 2
)

var WindowsDomainAccount_Role_name = map[int32]string{
	0: "MINION",
	1: "ADMIN",
	2: "SAFE_MODE_ADMIN",
}
var WindowsDomainAccount_Role_value = map[string]int32{
	"MINION":          0,
	"ADMIN":           1,
	"SAFE_MODE_ADMIN": 2,
}

func (x WindowsDomainAccount_Role) String() string {
	return proto.EnumName(WindowsDomainAccount_Role_name, int32(x))
}
func (WindowsDomainAccount_Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0}
}

// Version of address to use. Note that the enumeration values here
// correspond to the protocol names expected by GCE's
// compute.addresses.insert API.
type ExternalIP_Version int32

const (
	ExternalIP_IPV4 ExternalIP_Version = 0
	ExternalIP_IPV6 ExternalIP_Version = 1
)

var ExternalIP_Version_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}
var ExternalIP_Version_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x ExternalIP_Version) String() string {
	return proto.EnumName(ExternalIP_Version_name, int32(x))
}
func (ExternalIP_Version) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 0} }

// A network.
//
// Supported networks for the enterprise lab have autoCreateSubnetworks set to
// false.
type Network struct {
	// Name of the network. The partial URL for the network will be constructed
	// as "/projects/<project-name>/global/networks/<network-name>" where
	// <network-name> is the value of this |name| field.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Description of network.
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// IPV4 address range in CIDR format. Lab networks are required to specify
	// IPv4 subranges within 10.0.0.0/9. No two networks may have overlapping
	// ranges.
	//
	// Subnetworks are created automatically for each zone which contains an
	// instance. They can also be specified explicitly where necessary when
	// deterministic IP address range assignment is desired.
	Ipv4AddressRange string `protobuf:"bytes,3,opt,name=ipv4_address_range,json=ipv4AddressRange" json:"ipv4_address_range,omitempty"`
	// Firewall rules. Networks aren't created in auto mode, so firewall rules
	// are required to allow ingress traffic to the instances.
	FirewallRule []*FirewallRule       `protobuf:"bytes,4,rep,name=firewall_rule,json=firewallRule" json:"firewall_rule,omitempty"`
	Subnetwork   []*Network_Subnetwork `protobuf:"bytes,5,rep,name=subnetwork" json:"subnetwork,omitempty"`
	// Peer network names. Specify just the network name. The full URL is not necessary.
	//
	// See https://cloud.google.com/compute/docs/vpc/vpc-peering for more
	// information about network peering. The builtin networks will automatically
	// peer with all created networks. This is required for correctly deploying
	// the test infrastructure.
	//
	// If network A sets network B as its peer, then both A and B will have full
	// mesh routing for all their subnetworks. It is not necessary for network B
	// to specify A as a peer.
	Peer []string `protobuf:"bytes,6,rep,name=peer" json:"peer,omitempty"`
	// Setting |allow_internal_access| causes the 'default-allow-internal'
	// firewall rule to be applied which allows all internal traffic.
	AllowInternalAccess bool `protobuf:"varint,7,opt,name=allow_internal_access,json=allowInternalAccess" json:"allow_internal_access,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Network) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Network) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Network) GetIpv4AddressRange() string {
	if m != nil {
		return m.Ipv4AddressRange
	}
	return ""
}

func (m *Network) GetFirewallRule() []*FirewallRule {
	if m != nil {
		return m.FirewallRule
	}
	return nil
}

func (m *Network) GetSubnetwork() []*Network_Subnetwork {
	if m != nil {
		return m.Subnetwork
	}
	return nil
}

func (m *Network) GetPeer() []string {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Network) GetAllowInternalAccess() bool {
	if m != nil {
		return m.AllowInternalAccess
	}
	return false
}

// Subnetworks.
//
// See https://cloud.google.com/compute/docs/vpc/#vpc_networks_and_subnets . Each
// VPC network needs to be subdivided into subnetworks that are local to a region.
//
// Defining subnetworks in this manner is optional, and only necessary where
// IP address range assignment needs to be deterministic. If a subnetwork for
// a region is not specified, and an instance in that network is placed into
// a zone that's not covered by an existing subnetwork, one will be created
// automatically.
type Network_Subnetwork struct {
	// Name of the subnetwork. Must comply with RFC 1035.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Optional description. This would be a good place to explain why this
	// subnetwork is being explicitly specified.
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// Region name. E.g. "us-central1".
	Region string `protobuf:"bytes,3,opt,name=region" json:"region,omitempty"`
	// IPv4 address range in CIDR format. Must be a strict subset of the
	// enclosing network's |ipv4_address_range|.
	Ipv4AddressRange string `protobuf:"bytes,4,opt,name=ipv4_address_range,json=ipv4AddressRange" json:"ipv4_address_range,omitempty"`
}

func (m *Network_Subnetwork) Reset()                    { *m = Network_Subnetwork{} }
func (m *Network_Subnetwork) String() string            { return proto.CompactTextString(m) }
func (*Network_Subnetwork) ProtoMessage()               {}
func (*Network_Subnetwork) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *Network_Subnetwork) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Network_Subnetwork) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Network_Subnetwork) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Network_Subnetwork) GetIpv4AddressRange() string {
	if m != nil {
		return m.Ipv4AddressRange
	}
	return ""
}

// Firewall rules.
//
// See [1] https://cloud.google.com/compute/docs/reference/latest/firewalls for
// details. The configuration file currently only allows specifying firewall
// rules based on instance tags.
//
// Note: Google owned GCE projects will override these firewall rules.
// Hence the rules are unenforceable for such projects. See go/gce-enforcer.
// Googlers need to request exceptions for their projects in order for these
// network configurations to work.
//
// In the absence of any firewall rules, instances within the network will
// not be able to talk to each other due to the *-default-deny-ingress rule
// (explained in [1]).
//
// Setting |allow_internal_access| causes the 'default-allow-internal'
// firewall rule to be applied which allows all internal traffic.
//
// These rules do not allow remote access to instances from outside the GCE
// project. Such rules should be added manually if needed.
type FirewallRule struct {
	// Label for firewall rule.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// An optional description.
	Description string                  `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	Allowed     []*FirewallRule_Allowed `protobuf:"bytes,3,rep,name=allowed" json:"allowed,omitempty"`
	// Tags that should be on the VM initiating the traffic.
	SourceTag []string `protobuf:"bytes,4,rep,name=source_tag,json=sourceTag" json:"source_tag,omitempty"`
	// Tags that should be on the VM receiving the traffic.
	TargetTag []string `protobuf:"bytes,5,rep,name=target_tag,json=targetTag" json:"target_tag,omitempty"`
}

func (m *FirewallRule) Reset()                    { *m = FirewallRule{} }
func (m *FirewallRule) String() string            { return proto.CompactTextString(m) }
func (*FirewallRule) ProtoMessage()               {}
func (*FirewallRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *FirewallRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FirewallRule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FirewallRule) GetAllowed() []*FirewallRule_Allowed {
	if m != nil {
		return m.Allowed
	}
	return nil
}

func (m *FirewallRule) GetSourceTag() []string {
	if m != nil {
		return m.SourceTag
	}
	return nil
}

func (m *FirewallRule) GetTargetTag() []string {
	if m != nil {
		return m.TargetTag
	}
	return nil
}

// Describes the type of traffic that's allowed by this firewall exception.
type FirewallRule_Allowed struct {
	// One of "tcp", "udp", "icmp", "sctp" etc.. The special protocol "*"
	// causes TCP, UDP, and ICMP protocols to be added to the allow list.
	// Both TCP and UDP will allow traffic from the ports specified under
	// |ports|.
	Protocol string `protobuf:"bytes,1,opt,name=protocol" json:"protocol,omitempty"`
	// Individual ports in string form or '-' separated ranges. E.g.: "22",
	// "80","443","12345-12349", or my favorite "1-65535"
	Ports []string `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
}

func (m *FirewallRule_Allowed) Reset()                    { *m = FirewallRule_Allowed{} }
func (m *FirewallRule_Allowed) String() string            { return proto.CompactTextString(m) }
func (*FirewallRule_Allowed) ProtoMessage()               {}
func (*FirewallRule_Allowed) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

func (m *FirewallRule_Allowed) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *FirewallRule_Allowed) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

// A source disk image.
type SourceImage struct {
	// The name is used to refer to a source image from InstanceCreateOptions (or
	// other places as applicable) and has no significance outside of the
	// configuration file.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Obviously only one of these types can be specified per image.
	//
	// Types that are valid to be assigned to SourceType:
	//	*SourceImage_Latest_
	//	*SourceImage_Fixed_
	SourceType isSourceImage_SourceType `protobuf_oneof:"source_type"`
}

func (m *SourceImage) Reset()                    { *m = SourceImage{} }
func (m *SourceImage) String() string            { return proto.CompactTextString(m) }
func (*SourceImage) ProtoMessage()               {}
func (*SourceImage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isSourceImage_SourceType interface {
	isSourceImage_SourceType()
}

type SourceImage_Latest_ struct {
	Latest *SourceImage_Latest `protobuf:"bytes,2,opt,name=latest,oneof"`
}
type SourceImage_Fixed_ struct {
	Fixed *SourceImage_Fixed `protobuf:"bytes,3,opt,name=fixed,oneof"`
}

func (*SourceImage_Latest_) isSourceImage_SourceType() {}
func (*SourceImage_Fixed_) isSourceImage_SourceType()  {}

func (m *SourceImage) GetSourceType() isSourceImage_SourceType {
	if m != nil {
		return m.SourceType
	}
	return nil
}

func (m *SourceImage) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SourceImage) GetLatest() *SourceImage_Latest {
	if x, ok := m.GetSourceType().(*SourceImage_Latest_); ok {
		return x.Latest
	}
	return nil
}

func (m *SourceImage) GetFixed() *SourceImage_Fixed {
	if x, ok := m.GetSourceType().(*SourceImage_Fixed_); ok {
		return x.Fixed
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SourceImage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SourceImage_OneofMarshaler, _SourceImage_OneofUnmarshaler, _SourceImage_OneofSizer, []interface{}{
		(*SourceImage_Latest_)(nil),
		(*SourceImage_Fixed_)(nil),
	}
}

func _SourceImage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SourceImage)
	// source_type
	switch x := m.SourceType.(type) {
	case *SourceImage_Latest_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Latest); err != nil {
			return err
		}
	case *SourceImage_Fixed_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fixed); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SourceImage.SourceType has unexpected type %T", x)
	}
	return nil
}

func _SourceImage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SourceImage)
	switch tag {
	case 2: // source_type.latest
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SourceImage_Latest)
		err := b.DecodeMessage(msg)
		m.SourceType = &SourceImage_Latest_{msg}
		return true, err
	case 3: // source_type.fixed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SourceImage_Fixed)
		err := b.DecodeMessage(msg)
		m.SourceType = &SourceImage_Fixed_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SourceImage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SourceImage)
	// source_type
	switch x := m.SourceType.(type) {
	case *SourceImage_Latest_:
		s := proto.Size(x.Latest)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SourceImage_Fixed_:
		s := proto.Size(x.Fixed)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Describes the latest image from a public or private image source. See
// https://cloud.google.com/compute/docs/images#os-compute-support
//
// When creating an instance that uses a OS family + project,
// the instance will use the most recent matching image. If you want an
// instance to use a specific version of an image (not recommended), then use
// the full URL of that image with the |fixed| field set below.
type SourceImage_Latest struct {
	// Image family. See
	// https://cloud.google.com/compute/docs/images#image_families
	// This field should be set to the family label, *not* the full URL.
	Family string `protobuf:"bytes,1,opt,name=family" json:"family,omitempty"`
	// Image project. I.e. the project providing the image.
	Project string `protobuf:"bytes,2,opt,name=project" json:"project,omitempty"`
}

func (m *SourceImage_Latest) Reset()                    { *m = SourceImage_Latest{} }
func (m *SourceImage_Latest) String() string            { return proto.CompactTextString(m) }
func (*SourceImage_Latest) ProtoMessage()               {}
func (*SourceImage_Latest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

func (m *SourceImage_Latest) GetFamily() string {
	if m != nil {
		return m.Family
	}
	return ""
}

func (m *SourceImage_Latest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

// Describes a specific version of an image using a partial URL.
type SourceImage_Fixed struct {
	// Partial image URL. Looks like projects/*/global/images/*. E.g.:
	// projects/windows-sql-cloud/global/images/sql-2016-web-windows-2016-dc-v20170615
	// Note that project deployment may fail if the specified image has been
	// deprecated.
	ImageUrl string `protobuf:"bytes,1,opt,name=image_url,json=imageUrl" json:"image_url,omitempty"`
}

func (m *SourceImage_Fixed) Reset()                    { *m = SourceImage_Fixed{} }
func (m *SourceImage_Fixed) String() string            { return proto.CompactTextString(m) }
func (*SourceImage_Fixed) ProtoMessage()               {}
func (*SourceImage_Fixed) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 1} }

func (m *SourceImage_Fixed) GetImageUrl() string {
	if m != nil {
		return m.ImageUrl
	}
	return ""
}

// Describes a service account.
type ServiceAccount struct {
	// Unique ID for the service account. The email address and the URL of the
	// service account will be derived from this. IDs must be unique within a
	// single project.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Display name. Could be anything. Used in the UI.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
}

func (m *ServiceAccount) Reset()                    { *m = ServiceAccount{} }
func (m *ServiceAccount) String() string            { return proto.CompactTextString(m) }
func (*ServiceAccount) ProtoMessage()               {}
func (*ServiceAccount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ServiceAccount) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ServiceAccount) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// A service account bound to a VM instance. The service account identified by
// |id| must be defined a |ServiceAccount| resource elsewhere.
type InstanceServiceAccount struct {
	// Unique ID of service account. This must correspond to a ServiceAccount
	// declared elsewhere in the configuration. The email address will be
	// resolved after the corresponding service account has been looked up or
	// created in the GCE project.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// One or more authorization scopes to be granted to the account. Obviously
	// these must be a subset of those that can be granted to the service
	// account.
	//
	// |scope| can either be a label, or a full URL. When specifying the label,
	// the "https://www.googleapis.com/auth/" prefix is applied implictly. Note
	// that 'logging.write' and 'devstorage.read_only' are required. Otherwise
	// the automated deployment steps will fail.
	Scope []string `protobuf:"bytes,2,rep,name=scope" json:"scope,omitempty"`
}

func (m *InstanceServiceAccount) Reset()                    { *m = InstanceServiceAccount{} }
func (m *InstanceServiceAccount) String() string            { return proto.CompactTextString(m) }
func (*InstanceServiceAccount) ProtoMessage()               {}
func (*InstanceServiceAccount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *InstanceServiceAccount) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InstanceServiceAccount) GetScope() []string {
	if m != nil {
		return m.Scope
	}
	return nil
}

// A Google Cloud KMS key. The key will be placed in the 'global' location with
// the project identified by the LabConfig.
type Key struct {
	// Keyring name. Only the name should be specified here.  Not the full or
	// partial URL. The name will be resolved against the 'global' location for
	// the lab's project.
	Keyring string `protobuf:"bytes,1,opt,name=keyring" json:"keyring,omitempty"`
	// Cryptokey name. Only the name is required, not the full or partial URL.
	// The key is resolved against the keyring specified above.  E.g.: lab-key
	Cryptokey string `protobuf:"bytes,2,opt,name=cryptokey" json:"cryptokey,omitempty"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Key) GetKeyring() string {
	if m != nil {
		return m.Keyring
	}
	return ""
}

func (m *Key) GetCryptokey() string {
	if m != nil {
		return m.Cryptokey
	}
	return ""
}

// Options for creating a VM. The name of the instance is inherited from the
// parent Instance. Hence there is no separate field for it.
type InstanceCreateOptions struct {
	// GCE Zone. If empty, will inherit LabConfig.default_zone. E.g.:
	// "us-east1-b"
	Zone string `protobuf:"bytes,1,opt,name=zone" json:"zone,omitempty"`
	// Lab instances are assigned a disk with the following attributes:
	//   AutoDelete = true
	//   Boot = true
	//   DeviceName = undefined
	//   DiskEncryptionKey = undefined
	//   Index = undefined
	//   Interface = 'SCSI'
	//   Mode = 'READ_WRITE'
	//   Source = undefined
	//   Type = 'PERSISTENT'
	//   DiskName = undefined
	//   DiskSizeGb = undefined
	//   DiskType = undefined
	//   SourceImageEncryptionKey = undefined
	//
	// The base image for the instance. Should match the .name field of one of the
	// SourceImages described in the containing LabConfig.
	Image string `protobuf:"bytes,3,opt,name=image" json:"image,omitempty"`
	// Short machine type. E.g.: "n1-standard-1". Should be available under the
	// instance's zone.  See: https://cloud.google.com/compute/docs/machine-types
	MachineType string `protobuf:"bytes,4,opt,name=machine_type,json=machineType" json:"machine_type,omitempty"`
	// Instance metadata. Mapping key to value. Additional metadata will be added
	// by the lab management scripts.
	Metadata map[string]string `protobuf:"bytes,5,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Network interfaces. It is possible to have up to 8 of these. At least one
	// is requried. If an instance's instance type specifies interfaces and an
	// instance has no interfaces, then the interface will inherit the interfaces
	// from the instance type. Otherwise only the interfaces defined in the
	// instance are available in the VM.
	Interface []*NetworkInterface `protobuf:"bytes,6,rep,name=interface" json:"interface,omitempty"`
	// Set to true if the machine should be restarted automatically.
	AutomaticRestart bool `protobuf:"varint,7,opt,name=automatic_restart,json=automaticRestart" json:"automatic_restart,omitempty"`
	// Action to be taken during on-host maintenance. This value is not
	// inheritable. If a value is not specified for the instance, it will
	// default to MIGRATE.
	OnHostMaintenance InstanceCreateOptions_MaintenanceOption `protobuf:"varint,8,opt,name=on_host_maintenance,json=onHostMaintenance,enum=config.InstanceCreateOptions_MaintenanceOption" json:"on_host_maintenance,omitempty"`
	// Whether the instance should be preemptible. Only set to true for
	// instances that users will interact with manually.
	//
	// *Note*: If this field is set to |true| for an instance type then *all*
	// instances based on that type will become preemptible regardless of whether
	// the preemptible field is specified for an instance.
	Preemptible bool `protobuf:"varint,9,opt,name=preemptible" json:"preemptible,omitempty"`
	// Service account to use as the default authentication principal for the VM.
	// One must be specified unless the VM doesn't require access to GCE
	// resources.
	ServiceAccount *InstanceServiceAccount `protobuf:"bytes,10,opt,name=service_account,json=serviceAccount" json:"service_account,omitempty"`
	// KMS crypto key to use for passing in domain account or other privileged
	// information into this VM instance.
	//
	// The crypto_key is required for all instances.
	Cryptokey *Key `protobuf:"bytes,11,opt,name=cryptokey" json:"cryptokey,omitempty"`
	// Tags to apply to this instance. These are used within the lab to assign
	// instances to a network partition. Possible values are 'commons', 'group-a'
	// and 'group-b'.
	Tag []string `protobuf:"bytes,12,rep,name=tag" json:"tag,omitempty"`
}

func (m *InstanceCreateOptions) Reset()                    { *m = InstanceCreateOptions{} }
func (m *InstanceCreateOptions) String() string            { return proto.CompactTextString(m) }
func (*InstanceCreateOptions) ProtoMessage()               {}
func (*InstanceCreateOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *InstanceCreateOptions) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *InstanceCreateOptions) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *InstanceCreateOptions) GetMachineType() string {
	if m != nil {
		return m.MachineType
	}
	return ""
}

func (m *InstanceCreateOptions) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *InstanceCreateOptions) GetInterface() []*NetworkInterface {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *InstanceCreateOptions) GetAutomaticRestart() bool {
	if m != nil {
		return m.AutomaticRestart
	}
	return false
}

func (m *InstanceCreateOptions) GetOnHostMaintenance() InstanceCreateOptions_MaintenanceOption {
	if m != nil {
		return m.OnHostMaintenance
	}
	return InstanceCreateOptions_MIGRATE
}

func (m *InstanceCreateOptions) GetPreemptible() bool {
	if m != nil {
		return m.Preemptible
	}
	return false
}

func (m *InstanceCreateOptions) GetServiceAccount() *InstanceServiceAccount {
	if m != nil {
		return m.ServiceAccount
	}
	return nil
}

func (m *InstanceCreateOptions) GetCryptokey() *Key {
	if m != nil {
		return m.Cryptokey
	}
	return nil
}

func (m *InstanceCreateOptions) GetTag() []string {
	if m != nil {
		return m.Tag
	}
	return nil
}

type NetworkInterface struct {
	// Nickname of network hosting this instance. The nickname needs to be
	// resolvable via LabConfig.networks or should be a global network that's
	// identified via "projects/<project>/global/networks/<network>".
	Network string `protobuf:"bytes,1,opt,name=network" json:"network,omitempty"`
	// Internal static IPv4 address, if there should be one. Leave undefined
	// for ephemeral address. E.g.: "10.240.0.1". Not valid when specified for
	// an instance type.
	InternalIp string `protobuf:"bytes,2,opt,name=internal_ip,json=internalIp" json:"internal_ip,omitempty"`
	// Whether the network interface has a route from the internet. If true, the
	// network interface will receive an access config that'll either assign an
	// ephemeral external IP or a static external IP based on the value in
	// |external_ip_name|. Not valid when specified for an instance type.
	ExternallyVisible bool `protobuf:"varint,3,opt,name=externally_visible,json=externallyVisible" json:"externally_visible,omitempty"`
	// If not empty, this should be a named external IP from the external IP
	// pool in the HostEnvironment. Not valid when specified for an instance
	// type. Not valid when |externally_visible| is false.
	ExternalIpName string `protobuf:"bytes,4,opt,name=external_ip_name,json=externalIpName" json:"external_ip_name,omitempty"`
}

func (m *NetworkInterface) Reset()                    { *m = NetworkInterface{} }
func (m *NetworkInterface) String() string            { return proto.CompactTextString(m) }
func (*NetworkInterface) ProtoMessage()               {}
func (*NetworkInterface) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *NetworkInterface) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *NetworkInterface) GetInternalIp() string {
	if m != nil {
		return m.InternalIp
	}
	return ""
}

func (m *NetworkInterface) GetExternallyVisible() bool {
	if m != nil {
		return m.ExternallyVisible
	}
	return false
}

func (m *NetworkInterface) GetExternalIpName() string {
	if m != nil {
		return m.ExternalIpName
	}
	return ""
}

// Describes a single instance.
type Instance struct {
	// Hostname of the machine. This performs double duty as the GCE instance
	// name in addition to the hostname.
	//
	// Note: Windows VMs are limited to 15 characters for its hostname due to the
	// fact that we need to use the NetBIOS name for deploying via DSC.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Description for this instance.
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// The name of the role served by this machine. The role has no meaning to
	// GCE, and is used solely for managing configuration settings via DSC.
	Role string `protobuf:"bytes,3,opt,name=role" json:"role,omitempty"`
	// Type of instance. Must be one of the instance types defined in Assets. Can
	// be left empty if there's no base type.
	Type string `protobuf:"bytes,4,opt,name=type" json:"type,omitempty"`
	// Parameters for creating the machine. Values specified here override those
	// that are determined based on the instance type in |type|.
	CreateOptions *InstanceCreateOptions `protobuf:"bytes,5,opt,name=create_options,json=createOptions" json:"create_options,omitempty"`
}

func (m *Instance) Reset()                    { *m = Instance{} }
func (m *Instance) String() string            { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()               {}
func (*Instance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Instance) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Instance) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Instance) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *Instance) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Instance) GetCreateOptions() *InstanceCreateOptions {
	if m != nil {
		return m.CreateOptions
	}
	return nil
}

// Describes an instance type.
//
// Instance types exist purely for the convenience of describing lots of
// instances that reuse the same set of create_options with few modifications.
type InstanceType struct {
	// Instance type name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Create options. The properties here may be overridden by individual
	// instances.
	CreateOptions *InstanceCreateOptions `protobuf:"bytes,2,opt,name=create_options,json=createOptions" json:"create_options,omitempty"`
}

func (m *InstanceType) Reset()                    { *m = InstanceType{} }
func (m *InstanceType) String() string            { return proto.CompactTextString(m) }
func (*InstanceType) ProtoMessage()               {}
func (*InstanceType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *InstanceType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InstanceType) GetCreateOptions() *InstanceCreateOptions {
	if m != nil {
		return m.CreateOptions
	}
	return nil
}

// A Windows domain account.
type WindowsDomainAccount struct {
	// Username of the account. Should be short and not include anything funky
	// like whitespace. The domain of the account is inferred from its container.
	Name string                    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Role WindowsDomainAccount_Role `protobuf:"varint,2,opt,name=role,enum=config.WindowsDomainAccount_Role" json:"role,omitempty"`
	// The user's full name for the purpose of creating the account. If not
	// specified or empty, the |name| will be used as the full name.
	FullName string `protobuf:"bytes,3,opt,name=full_name,json=fullName" json:"full_name,omitempty"`
}

func (m *WindowsDomainAccount) Reset()                    { *m = WindowsDomainAccount{} }
func (m *WindowsDomainAccount) String() string            { return proto.CompactTextString(m) }
func (*WindowsDomainAccount) ProtoMessage()               {}
func (*WindowsDomainAccount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *WindowsDomainAccount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WindowsDomainAccount) GetRole() WindowsDomainAccount_Role {
	if m != nil {
		return m.Role
	}
	return WindowsDomainAccount_MINION
}

func (m *WindowsDomainAccount) GetFullName() string {
	if m != nil {
		return m.FullName
	}
	return ""
}

// A Windows AD domain. Note that this is not the place to add details about
// how to configured the AD domain. That's a job for the DSC definition. The
// domain details from here are only used for managing domain account
// credentials.
type WindowsDomain struct {
	Name    string                  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Account []*WindowsDomainAccount `protobuf:"bytes,2,rep,name=account" json:"account,omitempty"`
}

func (m *WindowsDomain) Reset()                    { *m = WindowsDomain{} }
func (m *WindowsDomain) String() string            { return proto.CompactTextString(m) }
func (*WindowsDomain) ProtoMessage()               {}
func (*WindowsDomain) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *WindowsDomain) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WindowsDomain) GetAccount() []*WindowsDomainAccount {
	if m != nil {
		return m.Account
	}
	return nil
}

// EncryptedData objects are generated by the lab administrative logic and is
// defined here. They are not meant to be produced manually or via a textpb
// file.
//
// TODO(asanka): Move to a separate .proto file.
type EncryptedData struct {
	// Key version used to encrypt the data. This is the partial URL of the
	// keyversion. E.g.:
	// projects/*/locations/*/keyRings/*/cryptoKeys/*/cryptoKeyVersions/*
	KeyVersion string `protobuf:"bytes,2,opt,name=key_version,json=keyVersion" json:"key_version,omitempty"`
	// Encrypted raw data. No encoding. Opaque.
	Encrypted []byte `protobuf:"bytes,3,opt,name=encrypted,proto3" json:"encrypted,omitempty"`
}

func (m *EncryptedData) Reset()                    { *m = EncryptedData{} }
func (m *EncryptedData) String() string            { return proto.CompactTextString(m) }
func (*EncryptedData) ProtoMessage()               {}
func (*EncryptedData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *EncryptedData) GetKeyVersion() string {
	if m != nil {
		return m.KeyVersion
	}
	return ""
}

func (m *EncryptedData) GetEncrypted() []byte {
	if m != nil {
		return m.Encrypted
	}
	return nil
}

// Describes an external IP address that can be attached to an instance. The
// lifetime of the IP address is restricted to the lifetime of the instance.
// I.e. when the instance is purged, its corresponding IP address will also be
// released.
type ExternalIP struct {
	// Name to use for the IP address.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Description of the IP address. Defaults to "External <version> address
	// for <instance>".
	Description string             `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	Version     ExternalIP_Version `protobuf:"varint,4,opt,name=version,enum=config.ExternalIP_Version" json:"version,omitempty"`
	// The address.
	Address string `protobuf:"bytes,5,opt,name=address" json:"address,omitempty"`
}

func (m *ExternalIP) Reset()                    { *m = ExternalIP{} }
func (m *ExternalIP) String() string            { return proto.CompactTextString(m) }
func (*ExternalIP) ProtoMessage()               {}
func (*ExternalIP) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ExternalIP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExternalIP) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ExternalIP) GetVersion() ExternalIP_Version {
	if m != nil {
		return m.Version
	}
	return ExternalIP_IPV4
}

func (m *ExternalIP) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type HostEnvironment struct {
	// Project name. E.g.: "google.com:chrome-auth-lab". This field is required.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// Storage bucket to be used for deploying binaries to the VMs.
	// E.g.: "gs://chrome-auth-lab-staging/image"
	//
	// This bucket should be readable from all the VMs, and it should be writeable
	// from the machine used to build the deployment data.
	DeploymentBucket string `protobuf:"bytes,2,opt,name=deployment_bucket,json=deploymentBucket" json:"deployment_bucket,omitempty"`
	// Storage bucket to be used for storing keys. These keys should only be
	// accessible to the VM that's acting as the authoring node for the network.
	// E.g.: "gs://chrome-auth-lab-keys/domain"
	DomainKeyBucket string `protobuf:"bytes,3,opt,name=domain_key_bucket,json=domainKeyBucket" json:"domain_key_bucket,omitempty"`
	// Named external static IP addresses.
	StaticIp []*ExternalIP `protobuf:"bytes,4,rep,name=static_ip,json=staticIp" json:"static_ip,omitempty"`
}

func (m *HostEnvironment) Reset()                    { *m = HostEnvironment{} }
func (m *HostEnvironment) String() string            { return proto.CompactTextString(m) }
func (*HostEnvironment) ProtoMessage()               {}
func (*HostEnvironment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *HostEnvironment) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *HostEnvironment) GetDeploymentBucket() string {
	if m != nil {
		return m.DeploymentBucket
	}
	return ""
}

func (m *HostEnvironment) GetDomainKeyBucket() string {
	if m != nil {
		return m.DomainKeyBucket
	}
	return ""
}

func (m *HostEnvironment) GetStaticIp() []*ExternalIP {
	if m != nil {
		return m.StaticIp
	}
	return nil
}

type Assets struct {
	// All service accounts.
	ServiceAccount []*ServiceAccount `protobuf:"bytes,1,rep,name=service_account,json=serviceAccount" json:"service_account,omitempty"`
	// All networks.
	Network []*Network `protobuf:"bytes,2,rep,name=network" json:"network,omitempty"`
	// All source disk images.
	SourceImage []*SourceImage `protobuf:"bytes,3,rep,name=source_image,json=sourceImage" json:"source_image,omitempty"`
	// All instance types.
	InstanceType []*InstanceType `protobuf:"bytes,4,rep,name=instance_type,json=instanceType" json:"instance_type,omitempty"`
	// All VM instances.
	Instance []*Instance `protobuf:"bytes,5,rep,name=instance" json:"instance,omitempty"`
	// All Windows domains.
	WindowsDomain []*WindowsDomain `protobuf:"bytes,6,rep,name=windows_domain,json=windowsDomain" json:"windows_domain,omitempty"`
}

func (m *Assets) Reset()                    { *m = Assets{} }
func (m *Assets) String() string            { return proto.CompactTextString(m) }
func (*Assets) ProtoMessage()               {}
func (*Assets) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Assets) GetServiceAccount() []*ServiceAccount {
	if m != nil {
		return m.ServiceAccount
	}
	return nil
}

func (m *Assets) GetNetwork() []*Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *Assets) GetSourceImage() []*SourceImage {
	if m != nil {
		return m.SourceImage
	}
	return nil
}

func (m *Assets) GetInstanceType() []*InstanceType {
	if m != nil {
		return m.InstanceType
	}
	return nil
}

func (m *Assets) GetInstance() []*Instance {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *Assets) GetWindowsDomain() []*WindowsDomain {
	if m != nil {
		return m.WindowsDomain
	}
	return nil
}

func init() {
	proto.RegisterType((*Network)(nil), "config.Network")
	proto.RegisterType((*Network_Subnetwork)(nil), "config.Network.Subnetwork")
	proto.RegisterType((*FirewallRule)(nil), "config.FirewallRule")
	proto.RegisterType((*FirewallRule_Allowed)(nil), "config.FirewallRule.Allowed")
	proto.RegisterType((*SourceImage)(nil), "config.SourceImage")
	proto.RegisterType((*SourceImage_Latest)(nil), "config.SourceImage.Latest")
	proto.RegisterType((*SourceImage_Fixed)(nil), "config.SourceImage.Fixed")
	proto.RegisterType((*ServiceAccount)(nil), "config.ServiceAccount")
	proto.RegisterType((*InstanceServiceAccount)(nil), "config.InstanceServiceAccount")
	proto.RegisterType((*Key)(nil), "config.Key")
	proto.RegisterType((*InstanceCreateOptions)(nil), "config.InstanceCreateOptions")
	proto.RegisterType((*NetworkInterface)(nil), "config.NetworkInterface")
	proto.RegisterType((*Instance)(nil), "config.Instance")
	proto.RegisterType((*InstanceType)(nil), "config.InstanceType")
	proto.RegisterType((*WindowsDomainAccount)(nil), "config.WindowsDomainAccount")
	proto.RegisterType((*WindowsDomain)(nil), "config.WindowsDomain")
	proto.RegisterType((*EncryptedData)(nil), "config.EncryptedData")
	proto.RegisterType((*ExternalIP)(nil), "config.ExternalIP")
	proto.RegisterType((*HostEnvironment)(nil), "config.HostEnvironment")
	proto.RegisterType((*Assets)(nil), "config.Assets")
	proto.RegisterEnum("config.InstanceCreateOptions_MaintenanceOption", InstanceCreateOptions_MaintenanceOption_name, InstanceCreateOptions_MaintenanceOption_value)
	proto.RegisterEnum("config.WindowsDomainAccount_Role", WindowsDomainAccount_Role_name, WindowsDomainAccount_Role_value)
	proto.RegisterEnum("config.ExternalIP_Version", ExternalIP_Version_name, ExternalIP_Version_value)
}

func init() { proto.RegisterFile("config/config.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1376 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x5b, 0x6f, 0xdb, 0xc6,
	0x12, 0x36, 0x75, 0xd7, 0xe8, 0x62, 0x79, 0xed, 0x04, 0x3c, 0x4a, 0x72, 0xe2, 0x10, 0xe7, 0xc1,
	0xe7, 0x24, 0x47, 0x46, 0x5d, 0xd7, 0x68, 0x92, 0x5e, 0xa0, 0xc4, 0x4a, 0x42, 0xa4, 0x56, 0x82,
	0xb5, 0x9b, 0x3e, 0xf4, 0x81, 0x58, 0x53, 0x2b, 0x85, 0x35, 0x45, 0x12, 0xcb, 0x95, 0x1d, 0xf6,
	0x17, 0xb4, 0x7f, 0xa4, 0x8f, 0x05, 0x5a, 0xa0, 0xe8, 0x0f, 0xe9, 0x8f, 0xe9, 0x43, 0x5f, 0x8a,
	0xbd, 0x49, 0x94, 0xad, 0x34, 0x80, 0x9f, 0xc8, 0xb9, 0xee, 0xec, 0xcc, 0x37, 0x33, 0x0b, 0x9b,
	0x7e, 0x1c, 0x8d, 0x83, 0xc9, 0xae, 0xfa, 0xf4, 0x12, 0x16, 0xf3, 0x18, 0x55, 0x14, 0xe5, 0xfc,
	0x5e, 0x84, 0xea, 0x90, 0xf2, 0x8b, 0x98, 0x9d, 0x21, 0x04, 0xa5, 0x88, 0x4c, 0xa9, 0x6d, 0x6d,
	0x5b, 0x3b, 0x75, 0x2c, 0xff, 0xd1, 0x36, 0x34, 0x46, 0x34, 0xf5, 0x59, 0x90, 0xf0, 0x20, 0x8e,
	0xec, 0x82, 0x14, 0xe5, 0x59, 0xe8, 0x01, 0xa0, 0x20, 0x39, 0xdf, 0xf7, 0xc8, 0x68, 0xc4, 0x68,
	0x9a, 0x7a, 0x8c, 0x44, 0x13, 0x6a, 0x17, 0xa5, 0x62, 0x47, 0x48, 0xfa, 0x4a, 0x80, 0x05, 0x1f,
	0x3d, 0x84, 0xd6, 0x38, 0x60, 0xf4, 0x82, 0x84, 0xa1, 0xc7, 0x66, 0x21, 0xb5, 0x4b, 0xdb, 0xc5,
	0x9d, 0xc6, 0xde, 0x56, 0x4f, 0x47, 0xf7, 0x4c, 0x0b, 0xf1, 0x2c, 0xa4, 0xb8, 0x39, 0xce, 0x51,
	0xe8, 0x11, 0x40, 0x3a, 0x3b, 0x8d, 0x54, 0xb0, 0x76, 0x59, 0xda, 0x75, 0x8d, 0x9d, 0xbe, 0x43,
	0xef, 0x78, 0xae, 0x81, 0x73, 0xda, 0xe2, 0x6a, 0x09, 0xa5, 0xcc, 0xae, 0x6c, 0x17, 0xc5, 0xd5,
	0xc4, 0x3f, 0xda, 0x83, 0x1b, 0x24, 0x0c, 0xe3, 0x0b, 0x2f, 0x88, 0x38, 0x65, 0x11, 0x09, 0x3d,
	0xe2, 0xfb, 0x34, 0x4d, 0xed, 0xea, 0xb6, 0xb5, 0x53, 0xc3, 0x9b, 0x52, 0xe8, 0x6a, 0x59, 0x5f,
	0x8a, 0xba, 0x3f, 0x58, 0x00, 0xc7, 0x4b, 0x6e, 0xaf, 0x91, 0xb1, 0x9b, 0x50, 0x61, 0x74, 0x22,
	0x84, 0x2a, 0x4b, 0x9a, 0x7a, 0x4f, 0x26, 0x4b, 0xab, 0x33, 0xe9, 0xfc, 0x69, 0x41, 0x33, 0x9f,
	0xad, 0x6b, 0x06, 0x73, 0x00, 0x55, 0x79, 0x51, 0x3a, 0xb2, 0x8b, 0x32, 0xa5, 0xb7, 0x57, 0x95,
	0xa2, 0xd7, 0x57, 0x3a, 0xd8, 0x28, 0xa3, 0x3b, 0x00, 0x69, 0x3c, 0x63, 0x3e, 0xf5, 0x38, 0x99,
	0xc8, 0x2a, 0xd6, 0x71, 0x5d, 0x71, 0x4e, 0xc8, 0x44, 0x88, 0x39, 0x61, 0x13, 0xca, 0xa5, 0xb8,
	0xac, 0xc4, 0x8a, 0x73, 0x42, 0x26, 0xdd, 0xc7, 0x50, 0xd5, 0x1e, 0x51, 0x17, 0x6a, 0x12, 0x92,
	0x7e, 0x1c, 0xea, 0xd0, 0xe7, 0x34, 0xda, 0x82, 0x72, 0x12, 0x33, 0x9e, 0xda, 0x05, 0xe9, 0x40,
	0x11, 0xce, 0x5f, 0x16, 0x34, 0x8e, 0xe5, 0x49, 0xee, 0x94, 0x4c, 0x56, 0x5f, 0x7c, 0x1f, 0x2a,
	0x21, 0xe1, 0x34, 0xe5, 0xf2, 0xce, 0x39, 0xa0, 0xe4, 0x0c, 0x7b, 0x5f, 0x49, 0x8d, 0x17, 0x6b,
	0x58, 0xeb, 0xa2, 0x8f, 0xa0, 0x3c, 0x0e, 0xde, 0xc9, 0x54, 0x08, 0xa3, 0x7f, 0xad, 0x32, 0x7a,
	0x26, 0x14, 0x5e, 0xac, 0x61, 0xa5, 0xd9, 0x7d, 0x04, 0x15, 0xe5, 0x46, 0x94, 0x75, 0x4c, 0xa6,
	0x41, 0x98, 0xe9, 0x40, 0x34, 0x85, 0x6c, 0xa8, 0x26, 0x2c, 0xfe, 0x8e, 0xfa, 0x5c, 0xe7, 0xdf,
	0x90, 0xdd, 0xff, 0x40, 0x59, 0x7a, 0x43, 0xb7, 0xa0, 0x1e, 0x08, 0xe7, 0xde, 0x8c, 0xcd, 0x93,
	0x20, 0x19, 0x5f, 0xb3, 0xf0, 0x49, 0x0b, 0x1a, 0x26, 0xd3, 0x59, 0x42, 0x9d, 0xa7, 0xd0, 0x3e,
	0xa6, 0xec, 0x3c, 0xf0, 0x69, 0xdf, 0xf7, 0xe3, 0x59, 0xc4, 0x51, 0x1b, 0x0a, 0xc1, 0x48, 0x9b,
	0x15, 0x82, 0x11, 0xba, 0x07, 0xcd, 0x51, 0x90, 0x26, 0x21, 0xc9, 0x3c, 0x99, 0x17, 0x53, 0x75,
	0xc5, 0x1b, 0x92, 0x29, 0x75, 0xbe, 0x80, 0x9b, 0x6e, 0x94, 0x72, 0x12, 0xf9, 0xf4, 0x03, 0xce,
	0xb6, 0xa0, 0x9c, 0xfa, 0x71, 0x42, 0x4d, 0x09, 0x24, 0xe1, 0x7c, 0x0e, 0xc5, 0x97, 0x54, 0x5e,
	0xed, 0x8c, 0x66, 0x2c, 0x88, 0x26, 0xda, 0xc2, 0x90, 0xe8, 0x36, 0xd4, 0x7d, 0x96, 0x25, 0x3c,
	0x3e, 0xa3, 0x99, 0x0e, 0x60, 0xc1, 0x70, 0x7e, 0x2c, 0xc3, 0x0d, 0x73, 0xfe, 0x53, 0x46, 0x09,
	0xa7, 0xaf, 0x24, 0x1a, 0x53, 0x51, 0xcb, 0xef, 0xe3, 0x68, 0x5e, 0x4b, 0xf1, 0x2f, 0x42, 0x90,
	0xc9, 0xd0, 0xed, 0xa2, 0x08, 0x71, 0xcb, 0x29, 0xf1, 0xdf, 0x06, 0x91, 0xca, 0x8b, 0xee, 0x93,
	0x86, 0xe6, 0x9d, 0x64, 0x09, 0x45, 0xcf, 0xa1, 0x36, 0xa5, 0x9c, 0x8c, 0x08, 0x27, 0x7a, 0x5e,
	0xdc, 0x37, 0x15, 0x5d, 0x79, 0x7a, 0xef, 0x48, 0x6b, 0x0f, 0x22, 0xce, 0x32, 0x3c, 0x37, 0x46,
	0x07, 0x50, 0x97, 0x43, 0x62, 0x4c, 0x7c, 0x2a, 0x67, 0x48, 0x63, 0xcf, 0xbe, 0x34, 0x79, 0x5c,
	0x23, 0xc7, 0x0b, 0x55, 0x74, 0x1f, 0x36, 0xc8, 0x8c, 0xc7, 0x53, 0xc2, 0x03, 0xdf, 0x63, 0x34,
	0xe5, 0x84, 0x71, 0x3d, 0x5e, 0x3a, 0x73, 0x01, 0x56, 0x7c, 0xe4, 0xc1, 0x66, 0x1c, 0x79, 0x6f,
	0xe3, 0x94, 0x7b, 0x53, 0x22, 0x7c, 0x44, 0x22, 0x40, 0xbb, 0xb6, 0x6d, 0xed, 0xb4, 0xf7, 0x76,
	0x3f, 0x10, 0xf8, 0xc2, 0x40, 0xb1, 0xf0, 0x46, 0x1c, 0xbd, 0x88, 0x53, 0x9e, 0x13, 0x88, 0x61,
	0x90, 0x30, 0x4a, 0xa7, 0x09, 0x0f, 0x4e, 0x43, 0x6a, 0xd7, 0x65, 0x1c, 0x79, 0x16, 0x7a, 0x0e,
	0xeb, 0xa9, 0x82, 0x83, 0x98, 0x85, 0x02, 0x0f, 0x36, 0xc8, 0x4e, 0xf8, 0xf7, 0xe5, 0xe3, 0x97,
	0x51, 0x83, 0xdb, 0xe9, 0x32, 0x8a, 0xfe, 0x9b, 0x2f, 0x7f, 0x43, 0xba, 0x68, 0x18, 0x17, 0x2f,
	0x69, 0x96, 0xc3, 0x02, 0xea, 0x40, 0x51, 0x8c, 0x88, 0xa6, 0x84, 0x97, 0xf8, 0xed, 0x3e, 0x86,
	0xd6, 0x52, 0x21, 0x84, 0x8a, 0xf0, 0xa3, 0x30, 0x21, 0x7e, 0x05, 0x24, 0xce, 0x49, 0x38, 0x33,
	0xd8, 0x56, 0xc4, 0xa3, 0xc2, 0xa7, 0x96, 0xb3, 0x0b, 0x1b, 0x57, 0x92, 0x81, 0x1a, 0x50, 0x3d,
	0x72, 0x9f, 0xe3, 0xfe, 0xc9, 0xa0, 0xb3, 0x86, 0x5a, 0x50, 0x3f, 0x19, 0xe0, 0x23, 0x77, 0x28,
	0x48, 0xcb, 0xf9, 0xc9, 0x82, 0xce, 0xe5, 0x1a, 0x0a, 0x60, 0x9b, 0x45, 0xa3, 0x81, 0x6d, 0x46,
	0xfe, 0x5d, 0x68, 0xcc, 0xf7, 0x45, 0x90, 0xe8, 0xf3, 0xc1, 0xb0, 0xdc, 0x04, 0xfd, 0x1f, 0x10,
	0x7d, 0xa7, 0xa8, 0x30, 0xf3, 0xce, 0x83, 0x54, 0x26, 0xbb, 0x28, 0x93, 0xbd, 0xb1, 0x90, 0xbc,
	0x51, 0x02, 0xb4, 0x03, 0x1d, 0xc3, 0xf4, 0x82, 0x44, 0x35, 0xac, 0x82, 0x72, 0xdb, 0xf0, 0xdd,
	0x44, 0xf6, 0xec, 0xcf, 0x16, 0xd4, 0x4c, 0xfa, 0xaf, 0x39, 0xec, 0x11, 0x94, 0x58, 0x1c, 0x9a,
	0x46, 0x92, 0xff, 0x82, 0x97, 0xeb, 0x1f, 0xf9, 0x8f, 0x0e, 0xa1, 0xed, 0x4b, 0x7c, 0x79, 0xb1,
	0x02, 0x98, 0x5d, 0x96, 0x35, 0xbc, 0xf3, 0x8f, 0x28, 0xc4, 0x2d, 0x3f, 0x4f, 0x3a, 0x6f, 0xa1,
	0x69, 0xf4, 0x64, 0x3b, 0xae, 0x8a, 0xf9, 0xea, 0x49, 0x85, 0x6b, 0x9c, 0xf4, 0xab, 0x05, 0x5b,
	0xdf, 0x04, 0xd1, 0x28, 0xbe, 0x48, 0x0f, 0x63, 0xd1, 0x3c, 0x06, 0x87, 0xab, 0x8e, 0xfc, 0x44,
	0x27, 0xa1, 0x20, 0x1b, 0xeb, 0x9e, 0x39, 0x68, 0x95, 0x7d, 0x0f, 0xc7, 0x21, 0xd5, 0x79, 0xba,
	0x05, 0xf5, 0xf1, 0x2c, 0x0c, 0x55, 0x85, 0x54, 0x02, 0x6b, 0x82, 0x21, 0x6b, 0xb3, 0x07, 0x25,
	0xa1, 0x8a, 0x00, 0x2a, 0x47, 0xee, 0xd0, 0x7d, 0x35, 0xec, 0xac, 0xa1, 0x3a, 0x94, 0xfb, 0x87,
	0x47, 0xee, 0xb0, 0x63, 0xa1, 0x4d, 0x58, 0x3f, 0xee, 0x3f, 0x1b, 0x78, 0x47, 0xaf, 0x0e, 0x07,
	0x9e, 0x62, 0x16, 0x9c, 0x6f, 0xa1, 0xb5, 0x74, 0xe6, 0xca, 0x60, 0xc5, 0x7a, 0xd6, 0x9d, 0x58,
	0x58, 0x5e, 0xcf, 0xab, 0xe2, 0xc5, 0x46, 0xd9, 0x19, 0x42, 0x6b, 0x10, 0xc9, 0x26, 0xa3, 0xa3,
	0x43, 0x31, 0xc2, 0xee, 0x42, 0xe3, 0x8c, 0x66, 0xde, 0x39, 0x65, 0xe9, 0x02, 0x1c, 0x70, 0x46,
	0xb3, 0x37, 0x8a, 0x23, 0x26, 0x36, 0x35, 0x16, 0xf2, 0x7e, 0x4d, 0xbc, 0x60, 0x38, 0xbf, 0x58,
	0x00, 0x03, 0x83, 0xc7, 0xd7, 0xf3, 0x50, 0x0b, 0xef, 0x87, 0x5f, 0xf1, 0x2a, 0xfc, 0xf6, 0xa1,
	0x6a, 0xce, 0x2f, 0xc9, 0xe4, 0xcf, 0xb7, 0xf2, 0xc2, 0x75, 0x4f, 0xc7, 0x83, 0x8d, 0xaa, 0xe8,
	0x45, 0xfd, 0x22, 0x92, 0x28, 0xac, 0x63, 0x43, 0x3a, 0x77, 0xa0, 0x6a, 0xa2, 0xaf, 0x41, 0xc9,
	0x7d, 0xfd, 0x66, 0xbf, 0xb3, 0xa6, 0xff, 0x0e, 0x3a, 0x96, 0xf3, 0x9b, 0x05, 0xeb, 0x62, 0x06,
	0x0e, 0xa2, 0xf3, 0x80, 0xc5, 0xd1, 0x94, 0x46, 0x3c, 0xbf, 0x8c, 0xad, 0xa5, 0x65, 0x2c, 0x66,
	0xf5, 0x88, 0x26, 0x61, 0x9c, 0x09, 0x3d, 0xef, 0x74, 0xe6, 0x9f, 0x51, 0xb3, 0xb0, 0x3b, 0x0b,
	0xc1, 0x13, 0xc9, 0x47, 0xff, 0x83, 0x8d, 0x91, 0x4c, 0xbc, 0x27, 0x92, 0xaa, 0x95, 0xd5, 0x8d,
	0xd7, 0x95, 0xe0, 0x25, 0xcd, 0xb4, 0xee, 0x2e, 0xd4, 0x53, 0x2e, 0x37, 0x40, 0x90, 0xe8, 0xe7,
	0x2e, 0xba, 0x7a, 0x6f, 0x5c, 0x53, 0x4a, 0x6e, 0xe2, 0xfc, 0x51, 0x80, 0x4a, 0x3f, 0x4d, 0x29,
	0x4f, 0xd1, 0x97, 0x57, 0x07, 0xb2, 0x25, 0x3d, 0xdc, 0x9c, 0x3f, 0x4d, 0x3e, 0x34, 0x88, 0xe7,
	0x83, 0x4c, 0xe1, 0x67, 0xfd, 0xd2, 0xde, 0x5a, 0x4c, 0xb6, 0x03, 0x68, 0xea, 0x77, 0x86, 0xd9,
	0xb6, 0x42, 0x7f, 0x73, 0xc5, 0x1b, 0x08, 0xeb, 0x07, 0x89, 0x7a, 0x7e, 0x3d, 0x84, 0x56, 0xa0,
	0x9b, 0xd4, 0x6c, 0xe2, 0xa5, 0x27, 0x7d, 0x7e, 0x06, 0xe0, 0x66, 0x90, 0x9f, 0x08, 0x0f, 0xa0,
	0x66, 0x68, 0xbd, 0xa0, 0x3b, 0x97, 0xad, 0xf0, 0x5c, 0x03, 0x7d, 0x06, 0xed, 0x0b, 0x05, 0x7a,
	0x4f, 0xe5, 0x58, 0xaf, 0xe2, 0x1b, 0x2b, 0x5b, 0x02, 0xb7, 0x2e, 0xf2, 0xe4, 0x69, 0x45, 0xbe,
	0x2a, 0x3f, 0xfe, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x47, 0x4c, 0xc5, 0x0f, 0x0d, 0x00, 0x00,
}
